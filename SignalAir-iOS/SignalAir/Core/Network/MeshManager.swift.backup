import Foundation
import Combine
import MultipeerConnectivity

// MARK: - 網絡連接狀態統一定義
enum NetworkConnectionState: String, CaseIterable {
    case disconnected = "disconnected"      // 完全斷線
    case connecting = "connecting"          // 正在連接
    case connected = "connected"            // 已連接但未就緒
    case ready = "ready"                   // 完全就緒（包含密鑰交換）
    case reconnecting = "reconnecting"      // 重新連接中
    case failed = "failed"                 // 連接失敗
    
    var isActive: Bool {
        return self == .connected || self == .ready
    }
    
    var canSendMessages: Bool {
        return self == .ready
    }
    
    var displayName: String {
        switch self {
        case .disconnected: return "離線"
        case .connecting: return "連接中"
        case .connected: return "已連接"
        case .ready: return "就緒"
        case .reconnecting: return "重新連接"
        case .failed: return "連接失敗"
        }
    }
}

// MARK: - 網絡層級定義
enum NetworkLayer: String, CaseIterable {
    case physical = "physical"      // 物理層 (NetworkService)
    case mesh = "mesh"             // 網格層 (MeshManager)
    case application = "application" // 應用層 (BingoNetworkManager)
    
    var priority: Int {
        switch self {
        case .physical: return 3      // 最高優先級
        case .mesh: return 2
        case .application: return 1   // 最低優先級
        }
    }
}

// MARK: - 網絡狀態報告
struct NetworkLayerState {
    let layer: NetworkLayer
    let state: NetworkConnectionState
    let peerCount: Int
    let lastUpdate: Date
    let metadata: [String: Any]
    
    init(layer: NetworkLayer, state: NetworkConnectionState, peerCount: Int = 0, metadata: [String: Any] = [:]) {
        self.layer = layer
        self.state = state
        self.peerCount = peerCount
        self.lastUpdate = Date()
        self.metadata = metadata
    }
}

// MARK: - 統一網絡狀態協調器
@MainActor
class NetworkStateCoordinator: ObservableObject {
    
    // MARK: - Singleton
    static let shared = NetworkStateCoordinator()
    
    // MARK: - Published Properties
    @Published private(set) var overallState: NetworkConnectionState = .disconnected
    @Published private(set) var layerStates: [NetworkLayer: NetworkLayerState] = [:]
    @Published private(set) var connectedPeers: Set<String> = []
    @Published private(set) var activePeerCount: Int = 0
    @Published private(set) var isStable: Bool = false
    @Published private(set) var lastStateChange: Date = Date()
    
    // MARK: - State Publishers
    private let stateChangeSubject = PassthroughSubject<NetworkConnectionState, Never>()
    private let layerStateSubject = PassthroughSubject<NetworkLayerState, Never>()
    
    var stateChanges: AnyPublisher<NetworkConnectionState, Never> {
        stateChangeSubject.eraseToAnyPublisher()
    }
    
    var layerStateChanges: AnyPublisher<NetworkLayerState, Never> {
        layerStateSubject.eraseToAnyPublisher()
    }
    
    // MARK: - Internal State
    private var stateHistory: [NetworkConnectionState] = []
    private let maxHistorySize = 10
    private var stabilityTimer: Timer?
    private let stabilityThreshold: TimeInterval = 5.0 // 5秒穩定才算真正穩定
    
    // MARK: - Thread-Safe State Access
    private let stateQueue = DispatchQueue(label: "com.signalair.networkstate", attributes: .concurrent)
    private var _internalStates: [NetworkLayer: NetworkLayerState] = [:]
    
    private var internalStates: [NetworkLayer: NetworkLayerState] {
        get {
            return stateQueue.sync { _internalStates }
        }
        set {
            stateQueue.async(flags: .barrier) { [weak self] in
                self?._internalStates = newValue
            }
        }
    }
    
    // MARK: - Initialization
    private init() {
        setupStabilityMonitoring()
        print("🔗 NetworkStateCoordinator: 初始化完成")
    }
    
    // MARK: - Public API - Layer State Reporting
    
    /// 報告層級狀態更新
    func reportLayerState(_ layer: NetworkLayer, state: NetworkConnectionState, peerCount: Int = 0, metadata: [String: Any] = [:]) {
        let layerState = NetworkLayerState(layer: layer, state: state, peerCount: peerCount, metadata: metadata)
        
        // 線程安全更新
        var currentStates = internalStates
        currentStates[layer] = layerState
        internalStates = currentStates
        
        // 主線程更新發布屬性
        layerStates[layer] = layerState
        
        // 重新計算整體狀態
        calculateOverallState()
        
        // 發布層級狀態變更
        layerStateSubject.send(layerState)
        
        print("🔗 NetworkStateCoordinator: \(layer.rawValue) 層報告狀態 \(state.rawValue) (對等體: \(peerCount))")
    }
    
    /// 報告對等體連接變更
    func reportPeerConnection(_ peerID: String, connected: Bool, layer: NetworkLayer) {
        if connected {
            connectedPeers.insert(peerID)
        } else {
            connectedPeers.remove(peerID)
        }
        
        activePeerCount = connectedPeers.count
        
        // 更新對應層級的對等體數量
        if let layerState = layerStates[layer] {
            let updatedState = NetworkLayerState(
                layer: layer,
                state: layerState.state,
                peerCount: connected ? layerState.peerCount + 1 : max(0, layerState.peerCount - 1),
                metadata: layerState.metadata
            )
            reportLayerState(layer, state: layerState.state, peerCount: updatedState.peerCount, metadata: layerState.metadata)
        }
        
        print("🔗 NetworkStateCoordinator: 對等體 \(peerID) \(connected ? "連接" : "斷開") (\(layer.rawValue) 層)")
    }
    
    // MARK: - State Calculation
    
    /// 計算整體網絡狀態（基於所有層級狀態）
    private func calculateOverallState() {
        let states = Array(layerStates.values)
        
        // 如果沒有任何層級報告，保持斷線狀態
        guard !states.isEmpty else {
            updateOverallState(.disconnected)
            return
        }
        
        // 檢查各層級狀態
        let physicalState = layerStates[.physical]?.state ?? .disconnected
        let meshState = layerStates[.mesh]?.state ?? .disconnected
        let applicationState = layerStates[.application]?.state ?? .disconnected
        
        let newState: NetworkConnectionState
        
        // 狀態計算邏輯：必須所有層級都正常才算正常
        if physicalState == .failed || meshState == .failed || applicationState == .failed {
            newState = .failed
        } else if physicalState == .reconnecting || meshState == .reconnecting || applicationState == .reconnecting {
            newState = .reconnecting
        } else if physicalState == .connecting || meshState == .connecting || applicationState == .connecting {
            newState = .connecting
        } else if physicalState == .ready && meshState == .ready && applicationState == .ready {
            newState = .ready
        } else if physicalState.isActive && meshState.isActive && applicationState.isActive {
            newState = .connected
        } else {
            newState = .disconnected
        }
        
        updateOverallState(newState)
    }
    
    /// 更新整體狀態
    private func updateOverallState(_ newState: NetworkConnectionState) {
        guard newState != overallState else { return }
        
        let previousState = overallState
        overallState = newState
        lastStateChange = Date()
        
        // 更新狀態歷史
        stateHistory.append(newState)
        if stateHistory.count > maxHistorySize {
            stateHistory.removeFirst()
        }
        
        // 重置穩定性計時器
        resetStabilityTimer()
        
        // 發布狀態變更
        stateChangeSubject.send(newState)
        
        print("🔗 NetworkStateCoordinator: 整體狀態變更 \(previousState.rawValue) → \(newState.rawValue)")
    }
    
    // MARK: - Stability Monitoring
    
    /// 設置穩定性監控
    private func setupStabilityMonitoring() {
        // 穩定性檢查將在狀態變更時重置
    }
    
    /// 重置穩定性計時器
    private func resetStabilityTimer() {
        stabilityTimer?.invalidate()
        isStable = false
        
        stabilityTimer = Timer.scheduledTimer(withTimeInterval: stabilityThreshold, repeats: false) { [weak self] _ in
            Task { @MainActor in
                self?.markAsStable()
            }
        }
    }
    
    /// 標記為穩定狀態
    private func markAsStable() {
        isStable = true
        print("🔗 NetworkStateCoordinator: 網絡狀態已穩定 (\(overallState.rawValue))")
    }
    
    // MARK: - Convenience Extensions
    
    /// 快速報告物理層狀態
    func reportPhysicalLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.physical, state: state, peerCount: peerCount)
    }
    
    /// 快速報告網格層狀態
    func reportMeshLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.mesh, state: state, peerCount: peerCount)
    }
    
    /// 快速報告應用層狀態
    func reportApplicationLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.application, state: state, peerCount: peerCount)
    }
    
    // MARK: - Cleanup
    deinit {
        stabilityTimer?.invalidate()
        print("🔗 NetworkStateCoordinator: 已清理")
    }
}

// MARK: - Message Priority
enum MessagePriority: String, CaseIterable, Codable {
    case low = "low"
    case normal = "normal"
    case high = "high"
    case emergency = "emergency"
}

// MARK: - Mesh Network Protocol
@MainActor
protocol MeshNetworkProtocol {
    func broadcastMessage(_ data: Data, messageType: MeshMessageType)
    func sendDirectMessage(_ data: Data, to peerID: String, messageType: MeshMessageType)
    func getConnectedPeers() -> [String]
    func getNetworkTopology() -> [String: Set<String>]
}

// MARK: - Extended Message Types with Emergency Priority
enum ExtendedMeshMessageType: String, CaseIterable, Codable {
    case emergencyMedical = "emergency_medical"  // 最高優先級
    case emergencyDanger = "emergency_danger"    // 最高優先級
    case signal = "signal"
    case chat = "chat"
    case game = "game"
    case heartbeat = "heartbeat"
    case routingUpdate = "routing_update"
    case keyExchange = "key_exchange"
    case system = "system"
    
    var priority: Int {
        switch self {
        case .emergencyMedical: return 100  // 緊急醫療求助
        case .emergencyDanger: return 100   // 緊急危險警報
        case .signal: return 10
        case .keyExchange: return 9
        case .system: return 8
        case .heartbeat: return 7
        case .routingUpdate: return 6
        case .chat: return 5
        case .game: return 4
        }
    }
    
    var isEmergency: Bool {
        return self == .emergencyMedical || self == .emergencyDanger
    }
}

// MARK: - Simple Route Quality (簡化的路由品質)
struct SimpleRouteMetrics: Codable {
    let peerID: String
    var signalStrength: Float = -50.0        // -100 到 0 dBm，越接近0越好
    var packetLoss: Float = 0.0              // 0.0-1.0，越低越好
    var isReachable: Bool = true             // 是否可達
    var lastHeartbeat: Date = Date()         // 最後心跳時間
    
    // 簡單的路由評分（0.0-1.0）
    var routeScore: Float {
        guard isReachable else { return 0.0 }
        
        // 檢查是否超時（超過60秒沒心跳視為不可達）
        if Date().timeIntervalSince(lastHeartbeat) > 60.0 {
            return 0.0
        }
        
        // 信號強度評分：-100dBm=0分，-50dBm=1分
        let signalScore = max(0.0, min(1.0, (signalStrength + 100.0) / 50.0))
        
        // 丟包率評分：0%丟包=1分，100%丟包=0分
        let lossScore = max(0.0, 1.0 - packetLoss)
        
        // 簡單加權：信號強度60%，丟包率40%
        return signalScore * 0.6 + lossScore * 0.4
    }
    
    var isStale: Bool {
        return Date().timeIntervalSince(lastHeartbeat) > 60.0
    }
}

// MARK: - Emergency Route Cache (緊急路由快取)
class EmergencyRouteCache {
    private var metrics: [String: SimpleRouteMetrics] = [:]
    private var emergencyPaths: [String: [String]] = [:]  // 快取緊急路徑
    private let lock = NSLock()
    
    func updateMetrics(_ metrics: SimpleRouteMetrics) {
        lock.lock()
        defer { lock.unlock() }
        
        self.metrics[metrics.peerID] = metrics
        
        // 清理失效的節點
        self.metrics = self.metrics.filter { !$0.value.isStale }
    }
    
    func getMetrics(for peerID: String) -> SimpleRouteMetrics? {
        lock.lock()
        defer { lock.unlock() }
        
        return metrics[peerID]
    }
    
    func cacheEmergencyPath(to destination: String, path: [String]) {
        lock.lock()
        defer { lock.unlock() }
        
        emergencyPaths[destination] = path
    }
    
    func getEmergencyPath(to destination: String) -> [String]? {
        lock.lock()
        defer { lock.unlock() }
        
        return emergencyPaths[destination]
    }
    
    func clearStaleData() {
        lock.lock()
        defer { lock.unlock() }
        
        metrics = metrics.filter { !$0.value.isStale }
        
        // 清理無效的緊急路徑
        for (destination, path) in emergencyPaths {
            for nodeID in path {
                if let nodeMetrics = metrics[nodeID], !nodeMetrics.isReachable {
                    emergencyPaths.removeValue(forKey: destination)
                    break
                }
            }
        }
    }
    
    func getAllMetrics() -> [String: SimpleRouteMetrics] {
        lock.lock()
        defer { lock.unlock() }
        
        return metrics
    }
}

// MARK: - Simple Intelligent Router (簡化智能路由器)
class SimpleIntelligentRouter {
    private let routeCache = EmergencyRouteCache()
    private var failedNodes: Set<String> = []
    private let lock = NSLock()
    
    // 尋找最佳路由（優先考慮緊急訊息）
    func findBestRoute(from source: String, to destination: String, 
                      topology: LocalNetworkTopology, isEmergency: Bool = false) -> [String]? {
        
        // 1. 如果是緊急訊息，先檢查快取的緊急路徑
        if isEmergency, let emergencyPath = routeCache.getEmergencyPath(to: destination) {
            if isPathValid(emergencyPath) {
                return emergencyPath
            }
        }
        
        // 2. 尋找所有可能路徑
        let availablePaths = findMultiplePaths(from: source, to: destination, topology: topology)
        
        // 3. 評估路徑並選擇最佳的
        let bestPath = selectBestPath(availablePaths, isEmergency: isEmergency)
        
        // 4. 如果是緊急訊息，快取最佳路徑
        if isEmergency, let path = bestPath {
            routeCache.cacheEmergencyPath(to: destination, path: path)
        }
        
        return bestPath
    }
    
    // 尋找多條路徑（最多3條，避免過度計算）
    private func findMultiplePaths(from source: String, to destination: String, 
                                  topology: LocalNetworkTopology) -> [[String]] {
        var paths: [[String]] = []
        var excludeNodes: Set<String> = failedNodes
        
        // 最多找3條路徑
        for _ in 0..<3 {
            if let path = topology.findRoute(from: source, to: destination, excluding: excludeNodes) {
                paths.append(path)
                
                // 排除此路徑的中間節點以找到不同路徑
                if path.count > 2 {
                    for node in path[1..<path.count-1] {
                        excludeNodes.insert(node)
                    }
                }
            } else {
                break
            }
        }
        
        return paths
    }
    
    // 選擇最佳路徑（簡單但有效）
    private func selectBestPath(_ paths: [[String]], isEmergency: Bool) -> [String]? {
        guard !paths.isEmpty else { return nil }
        
        // 緊急訊息：選擇最短且最可靠的路徑
        if isEmergency {
            return paths.min { path1, path2 in
                let score1 = calculatePathReliability(path1)
                let score2 = calculatePathReliability(path2)
                
                // 如果可靠性相近，選擇較短的路徑
                if abs(score1 - score2) < 0.1 {
                    return path1.count < path2.count
                }
                return score1 > score2
            }
        }
        
        // 一般訊息：綜合考慮路徑品質和跳數
        return paths.max { path1, path2 in
            let score1 = calculatePathScore(path1)
            let score2 = calculatePathScore(path2)
            return score1 < score2
        }
    }
    
    // 計算路徑可靠性（用於緊急訊息）
    private func calculatePathReliability(_ path: [String]) -> Float {
        guard path.count > 1 else { return 0.0 }
        
        var totalReliability: Float = 1.0
        
        for nodeID in path {
            if let metrics = routeCache.getMetrics(for: nodeID) {
                // 只考慮是否可達和基本品質
                if metrics.isReachable && metrics.routeScore > 0.3 {
                    totalReliability *= metrics.routeScore
                } else {
                    return 0.0  // 任何一個節點不可靠，整條路徑就不可靠
                }
            } else {
                totalReliability *= 0.5  // 未知節點給予保守評分
            }
        }
        
        return totalReliability
    }
    
    // 計算路徑評分（用於一般訊息）
    private func calculatePathScore(_ path: [String]) -> Float {
        guard path.count > 1 else { return 0.0 }
        
        let reliability = calculatePathReliability(path)
        
        // 跳數懲罰：每增加一跳減少10%評分
        let hopPenalty = pow(0.9, Float(path.count - 2))
        
        return reliability * hopPenalty
    }
    
    // 檢查路徑是否有效
    private func isPathValid(_ path: [String]) -> Bool {
        for nodeID in path {
            if failedNodes.contains(nodeID) {
                return false
            }
            
            if let metrics = routeCache.getMetrics(for: nodeID), !metrics.isReachable {
                return false
            }
        }
        return true
    }
    
    // 標記故障節點
    func markNodeAsFailed(_ nodeID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        failedNodes.insert(nodeID)
        print("🚫 Marked node as failed: \(nodeID)")
    }
    
    // 恢復節點
    func markNodeAsRecovered(_ nodeID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        failedNodes.remove(nodeID)
        print("✅ Marked node as recovered: \(nodeID)")
    }
    
    // 更新節點指標
    func updateNodeMetrics(_ metrics: SimpleRouteMetrics) {
        routeCache.updateMetrics(metrics)
        
        // 如果節點恢復，從故障清單移除
        if metrics.isReachable && failedNodes.contains(metrics.peerID) {
            markNodeAsRecovered(metrics.peerID)
        }
    }
    
    // 獲取節點指標
    func getNodeMetrics(for peerID: String) -> SimpleRouteMetrics? {
        return routeCache.getMetrics(for: peerID)
    }
    
    // 獲取所有節點指標
    func getAllNodeMetrics() -> [String: SimpleRouteMetrics] {
        return routeCache.getAllMetrics()
    }
    
    // 清理過期資料
    func cleanup() {
        routeCache.clearStaleData()
        
        lock.lock()
        defer { lock.unlock() }
        
        // 清理長期故障的節點（超過5分鐘）
        let staleFailures = failedNodes.filter { nodeID in
            if let metrics = routeCache.getMetrics(for: nodeID) {
                return Date().timeIntervalSince(metrics.lastHeartbeat) > 300
            }
            return true
        }
        
        for nodeID in staleFailures {
            failedNodes.remove(nodeID)
        }
    }
}

// MARK: - Extended Mesh Message Structure
// 擴展 MeshMessage 以支援路由功能
struct ExtendedMeshMessage: Codable {
    let id: String
    let type: ExtendedMeshMessageType
    let sourceID: String
    let targetID: String? // nil for broadcast
    let data: Data
    let timestamp: Date
    let ttl: Int // Time To Live
    let hopCount: Int
    let routePath: [String] // 記錄路由路徑
    
    init(type: ExtendedMeshMessageType, sourceID: String, targetID: String? = nil, data: Data, ttl: Int? = nil) {
        self.id = UUID().uuidString
        self.type = type
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = Date()
        // 緊急訊息有更長的TTL
        self.ttl = ttl ?? (type.isEmergency ? 20 : 10)
        self.hopCount = 0
        self.routePath = [sourceID]
    }
    
    // 私有初始化器用於轉發
    private init(type: ExtendedMeshMessageType, sourceID: String, targetID: String?, data: Data, 
                timestamp: Date, ttl: Int, hopCount: Int, routePath: [String]) {
        self.id = UUID().uuidString
        self.type = type
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = timestamp
        self.ttl = ttl
        self.hopCount = hopCount
        self.routePath = routePath
    }
    
    // 創建轉發副本
    func forwarded(through peerID: String) -> ExtendedMeshMessage {
        return ExtendedMeshMessage(
            type: self.type,
            sourceID: self.sourceID,
            targetID: self.targetID,
            data: self.data,
            timestamp: self.timestamp,
            ttl: self.ttl - 1,
            hopCount: self.hopCount + 1,
            routePath: self.routePath + [peerID]
        )
    }
    
    var isExpired: Bool {
        let maxAge: TimeInterval = type.isEmergency ? 600 : 300  // 緊急訊息10分鐘，一般5分鐘
        return ttl <= 0 || Date().timeIntervalSince(timestamp) > maxAge
    }
    
    private init(type: MeshMessageType, sourceID: String, targetID: String? = nil, 
                 data: Data, timestamp: Date, ttl: Int, hopCount: Int, routePath: [String]) {
        self.id = UUID().uuidString
        self.type = ExtendedMeshMessageType(rawValue: type.stringValue) ?? .system
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = timestamp
        self.ttl = ttl
        self.hopCount = hopCount
        self.routePath = routePath
    }
}

// MARK: - Network Topology (簡化版)
class LocalNetworkTopology {
    private var connections: [String: Set<String>] = [:]
    private let lock = NSLock()
    
    func addConnection(from: String, to: String) {
        lock.lock()
        defer { lock.unlock() }
        
        connections[from, default: Set()].insert(to)
        connections[to, default: Set()].insert(from)
    }
    
    func removeConnection(from: String, to: String) {
        lock.lock()
        defer { lock.unlock() }
        
        connections[from]?.remove(to)
        connections[to]?.remove(from)
        
        if connections[from]?.isEmpty == true {
            connections.removeValue(forKey: from)
        }
        if connections[to]?.isEmpty == true {
            connections.removeValue(forKey: to)
        }
    }
    
    func removePeer(_ peerID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        if let connectedPeers = connections[peerID] {
            for peer in connectedPeers {
                connections[peer]?.remove(peerID)
                if connections[peer]?.isEmpty == true {
                    connections.removeValue(forKey: peer)
                }
            }
        }
        connections.removeValue(forKey: peerID)
    }
    
    func getConnections() -> [String: Set<String>] {
        lock.lock()
        defer { lock.unlock() }
        return connections
    }
    
    // 使用BFS尋找路徑（簡單可靠）
    func findRoute(from source: String, to target: String, excluding excludeNodes: Set<String> = []) -> [String]? {
        lock.lock()
        defer { lock.unlock() }
        
        guard source != target else { return [source] }
        guard !excludeNodes.contains(source) && !excludeNodes.contains(target) else { return nil }
        
        // BFS搜尋
        var queue: [(String, [String])] = [(source, [source])]
        var visited: Set<String> = [source]
        
        while !queue.isEmpty {
            let (current, path) = queue.removeFirst()
            
            if let neighbors = connections[current] {
                for neighbor in neighbors {
                    if neighbor == target {
                        return path + [neighbor]
                    }
                    
                    if !visited.contains(neighbor) && !excludeNodes.contains(neighbor) {
                        visited.insert(neighbor)
                        queue.append((neighbor, path + [neighbor]))
                    }
                }
            }
        }
        
        return nil // 無路徑
    }
}

// MARK: - Message Queue (緊急訊息優先)
class MessageQueue {
    private var emergencyQueue: [MeshMessage] = []  // 緊急訊息隊列
    private var normalQueue: [MeshMessage] = []     // 一般訊息隊列
    private let lock = NSLock()
    private let maxSize = 500  // 減少記憶體使用
    
    // 獲取訊息優先級
    private func getMessagePriority(for type: MeshMessageType) -> MessagePriority {
        switch type {
        case .emergency:
            return .emergency
        case .system, .keyExchange, .keyExchangeResponse:
            return .high
        default:
            return .normal
        }
    }
    
    func enqueue(_ message: MeshMessage) {
        lock.lock()
        defer { lock.unlock() }
        
        if message.type.isEmergency {
            emergencyQueue.append(message)
            
            // 限制緊急隊列大小
            if emergencyQueue.count > maxSize / 4 {
                emergencyQueue.removeFirst()
            }
        } else {
            // 一般訊息按優先級插入
            let messagePriority = getMessagePriority(for: message.type)
            let insertIndex = normalQueue.firstIndex { 
                let otherPriority = getMessagePriority(for: $0.type)
                return otherPriority.rawValue < messagePriority.rawValue 
            } ?? normalQueue.count
            normalQueue.insert(message, at: insertIndex)
            
            // 限制一般隊列大小
            if normalQueue.count > maxSize {
                normalQueue.removeLast()
            }
        }
    }
    
    func dequeue() -> MeshMessage? {
        lock.lock()
        defer { lock.unlock() }
        
        // 清理過期訊息
        emergencyQueue.removeAll { $0.isExpired }
        normalQueue.removeAll { $0.isExpired }
        
        // 緊急訊息優先
        if !emergencyQueue.isEmpty {
            return emergencyQueue.removeFirst()
        }
        
        return normalQueue.isEmpty ? nil : normalQueue.removeFirst()
    }
    
    func clear() {
        lock.lock()
        defer { lock.unlock() }
        emergencyQueue.removeAll()
        normalQueue.removeAll()
    }
    
    var count: Int {
        lock.lock()
        defer { lock.unlock() }
        return emergencyQueue.count + normalQueue.count
    }
    
    var emergencyCount: Int {
        lock.lock()
        defer { lock.unlock() }
        return emergencyQueue.count
    }
}

// MARK: - Network Statistics
struct NetworkStats {
    var messagesSent: Int = 0
    var messagesReceived: Int = 0
    var messagesForwarded: Int = 0
    var emergencyMessagesSent: Int = 0
    var emergencyMessagesReceived: Int = 0
    var connectedPeersCount: Int = 0
    var averageRouteLength: Double = 0.0
    var networkReliability: Float = 1.0
    var blockedConnections: Int = 0
    
    // 洪水防護統計
    var blockedMessages: Int = 0
    var lastBlockedPeer: String = ""
    var lastBlockedTime: Date = Date()
    var connectionRateProtectionEnabled: Bool = true
}

// MARK: - Connection Rate Manager Protocol
protocol ConnectionRateManagerProtocol {
    func shouldBlock(_ message: MeshMessage, from peerID: String) -> Bool
}

// NetworkServiceProtocol 定義已移至 ServiceProtocols.swift

// SecurityServiceProtocol 定義已移至 ServiceProtocols.swift

// MARK: - Simple Connection Rate Manager
class SimpleConnectionRateManager: ConnectionRateManagerProtocol {
    private var messageHistory: [String: [Date]] = [:]
    private let lock = NSLock()
    private let maxMessagesPerMinute = 60
    private let windowSize: TimeInterval = 60.0
    
    func shouldBlock(_ message: MeshMessage, from peerID: String) -> Bool {
        // 緊急訊息永不阻擋
        guard !message.type.isEmergency else { return false }
        
        lock.lock()
        defer { lock.unlock() }
        
        let now = Date()
        let cutoffTime = now.addingTimeInterval(-windowSize)
        
        // 清理過期記錄
        messageHistory[peerID] = messageHistory[peerID]?.filter { $0 > cutoffTime } ?? []
        
        // 檢查是否超過限制
        let recentCount = messageHistory[peerID]?.count ?? 0
        if recentCount >= maxMessagesPerMinute {
            print("🚫 Blocking excessive connections from \(peerID): \(recentCount) messages in last minute")
            return true
        }
        
        // 記錄此次訊息
        messageHistory[peerID, default: []].append(now)
        return false
    }
}

// MARK: - Mesh Manager (智能路由整合版)
@MainActor
class MeshManager: MeshNetworkProtocol, MeshManagerProtocol, ObservableObject {
    // MARK: - Dependencies
    private let networkService: NetworkServiceProtocol
    private let securityService: SecurityService
    private let connectionRateManager: ConnectionRateManagerProtocol
    private let advancedConnectionRateManager: ConnectionRateManager?
    private let trustScoreManager: TrustScoreManager
    private let networkStateCoordinator: NetworkStateCoordinator = NetworkStateCoordinator.shared
    
    // MARK: - Core Components
    private var topology = LocalNetworkTopology()
    private let messageQueue = MessageQueue()
    private let intelligentRouter = SimpleIntelligentRouter()
    private let emergencyRateLimiter = EmergencyRateLimiter()
    
    // 線程安全的 processedMessages 管理
    private let processedMessagesQueue = DispatchQueue(label: "com.signalair.meshmanager.messages", attributes: .concurrent)
    private var _processedMessages: Set<String> = []
    private let processedMessagesLimit = 1000  // 減少記憶體使用從5000降到1000
    
    // 【NEW】遊戲消息接收回調
    var onGameMessageReceived: ((MeshMessage) -> Void)?
    
    // 線程安全的 processedMessages 存取
    private var processedMessages: Set<String> {
        get {
            return processedMessagesQueue.sync { _processedMessages }
        }
        set {
            processedMessagesQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._processedMessages = newValue
                }
            }
        }
    }
    
    // MARK: - Timers
    private var heartbeatTimer: Timer?
    private var queueProcessingTimer: Timer?
    private var metricsCleanupTimer: Timer?
    
    // MARK: - Configuration (災難通信優化)
    private let heartbeatInterval: TimeInterval = 120.0     // 2分鐘心跳 (大規模mesh優化)  
    private let queueProcessingInterval: TimeInterval = 0.2  // 200ms處理間隔 (減少CPU負載)
    private let metricsCleanupInterval: TimeInterval = 300.0 // 5分鐘清理一次 (減少頻繁操作)
    
    // MARK: - Send Failure Tracking (線程安全)
    private let failureTrackingQueue = DispatchQueue(label: "com.signalair.meshmanager.failure", attributes: .concurrent)
    private var _sendFailureCounts: [String: Int] = [:]
    private var _lastFailureTime: [String: Date] = [:]
    private let maxFailureCount = 3  // 最多允許3次失敗
    private let failureResetInterval: TimeInterval = 300.0  // 5分鐘後重置失敗計數
    
    // 線程安全的失敗計數訪問
    private var sendFailureCounts: [String: Int] {
        get { 
            return failureTrackingQueue.sync { _sendFailureCounts } 
        }
        set { 
            failureTrackingQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._sendFailureCounts = newValue
                }
            }
        }
    }
    
    private var lastFailureTime: [String: Date] {
        get { 
            return failureTrackingQueue.sync { _lastFailureTime } 
        }
        set { 
            failureTrackingQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._lastFailureTime = newValue
                }
            }
        }
    }
    
    // MARK: - Published State
    @Published var connectedPeers: [String] = []
    @Published var networkStats: NetworkStats = NetworkStats()
    @Published var isActive: Bool = false
    @Published var routingMetrics: [String: SimpleRouteMetrics] = [:]
    
    // MARK: - Callbacks
    var onDataReceived: ((Data, MeshMessageType, String) -> Void)?
    var onNetworkTopologyChanged: (([String: Set<String>]) -> Void)?
    var onEmergencyMessage: ((Data, MeshMessageType, String) -> Void)?
    
    // MARK: - Protocol Callbacks (符合 MeshManagerProtocol)
    var onMessageReceived: ((MeshMessage) -> Void)?
    var onPeerConnected: ((String) -> Void)?
    var onPeerDisconnected: ((String) -> Void)?
    
    // MARK: - Initialization
    init(networkService: NetworkServiceProtocol, 
         securityService: SecurityService,
         trustScoreManager: TrustScoreManager,
         connectionRateManager: ConnectionRateManagerProtocol? = nil,
         advancedConnectionRateManager: ConnectionRateManager? = nil) {
        self.networkService = networkService
        self.securityService = securityService
        self.trustScoreManager = trustScoreManager
        
        // 優先使用高級洪水防護，回退到簡單版本
        if let advancedProtection = advancedConnectionRateManager {
            self.connectionRateManager = advancedProtection
            self.advancedConnectionRateManager = advancedProtection
            print("🛡️ Using advanced connection rate manager system")
        } else {
            self.connectionRateManager = connectionRateManager ?? SimpleConnectionRateManager()
            self.advancedConnectionRateManager = nil
            print("🛡️ Using simple connection rate manager system")
        }
        
        setupNetworkCallbacks()
        startServices()
        
        print("🕸️ MeshManager initialized with intelligent routing")
    }
    
    deinit {
        // 線程安全的 Timer 清理
        DispatchQueue.main.async { [weak self] in
            self?.heartbeatTimer?.invalidate()
            self?.queueProcessingTimer?.invalidate()
            self?.metricsCleanupTimer?.invalidate()
        }
        
        // 停止網路服務
        Task { @MainActor [weak self] in
            self?.stopMeshNetwork()
            self?.clearProcessedMessages()
        }
        
        print("🧹 MeshManager: 所有資源已清理")
    }
    
    // MARK: - Security Integration
    
    /// 通知安全監控系統
    private func notifySecurityHealthMonitor(event: SecurityEventType, peerID: String, details: String) async {
        // 使用 NotificationCenter 通知安全監控系統
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: NSNotification.Name("SecurityEvent"),
                object: nil,
                userInfo: [
                    "event": event.rawValue,
                    "peerID": peerID,
                    "details": details,
                    "timestamp": Date(),
                    "source": "MeshManager"
                ]
            )
        }
        
        print("⚠️ Security event reported: \(event.rawValue) from \(peerID)")
    }
    
    /// 檢查緊急訊息是否應該繞過連線速率保護
    /// 🔧 FIX: 整合緊急訊息專用速率限制器
    private func shouldBypassConnectionRateProtection(message: MeshMessage, from peerID: String) -> Bool {
        // 🚨 緊急訊息現在有專門的速率限制器
        if message.type.isEmergency {
            // 緊急訊息仍然需要通過專門的緊急速率檢查
            let allowed = emergencyRateLimiter.shouldAllowEmergencyMessage(from: peerID)
            if !allowed {
                print("🚫 緊急訊息被緊急速率限制器阻止: \(peerID)")
                // 記錄統計
                networkStats.blockedMessages += 1
                networkStats.lastBlockedPeer = peerID
                networkStats.lastBlockedTime = Date()
            }
            return allowed
        }
        
        // 系統關鍵訊息繞過連線速率保護
        if message.type == .system || message.type == .keyExchange {
            return true
        }
        
        return false
    }
    
    /// 檢查是否為遊戲通訊（白名單機制）
    private func isGameCommunication(message: MeshMessage) -> Bool {
        // 遊戲相關訊息類型白名單
        let gameMessageTypes: [MeshMessageType] = [
            .game,           // 賓果遊戲消息
            .routingUpdate,  // 路由更新
            .signal         // 信號消息
        ]
        
        // 檢查消息類型
        if gameMessageTypes.contains(message.type) {
            return true
        }
        
        // 檢查消息內容中的遊戲關鍵字
        if let messageContent = String(data: message.data, encoding: .utf8) {
            let gameKeywords = [
                "room_sync", "game_start", "number_drawn", "game_restart",
                "player_join", "player_leave", "bingo_card", "reconnect_request",
                "weekly_leaderboard", "host_promotion", "game_state"
            ]
            
            return gameKeywords.contains { messageContent.contains($0) }
        }
        
        return false
    }
    
    // MARK: - MeshNetworkProtocol Implementation
    
    func startMeshNetwork() {
        if !isActive {
            // 1. 報告網格層正在連接
            networkStateCoordinator.reportMeshLayerState(.connecting)
            
            startServices()
            
            // 2. 報告網格層已連接
            networkStateCoordinator.reportMeshLayerState(.connected, peerCount: getConnectedPeers().count)
            
            print("🕸️ MeshManager: Mesh 網路已啟動")
        }
    }
    
    func stopMeshNetwork() {
        if isActive {
            // 1. 報告網格層斷線
            networkStateCoordinator.reportMeshLayerState(.disconnected)
            
            stopServices()
            print("🛑 MeshManager: Mesh 網路已停止")
        }
    }
    
    func broadcastMessage(_ data: Data, messageType: MeshMessageType) {
        // 🚨 災難通信優化：防止消息風暴的廣播機制
        let connectedPeers = networkService.connectedPeers
        
        // 2. 檢查是否有連接的設備
        guard !connectedPeers.isEmpty else {
            print("📱 無連接設備，跳過廣播 \(messageType.rawValue)")
            return
        }
        
        // 3. 對緊急消息給予優先處理
        let isEmergency = messageType.isEmergency
        if isEmergency {
            print("🚨 緊急消息廣播: \(messageType.rawValue)")
        }
        
        // 4. 創建優化的MeshMessage
        let message = MeshMessage(
            id: UUID().uuidString,
            type: messageType,
            data: data
        )
        
        // 5. 二進制編碼（災難場景優化）
        do {
            let binaryData = try BinaryMessageEncoder.encode(message)
            let dataSize = binaryData.count
            
            // 6. 檢查數據大小（防止大數據包阻塞）
            if dataSize > 1024 && !isEmergency {
                print("⚠️ 非緊急消息過大 (\(dataSize) bytes)，考慮分片")
            }
            
            print("📦 廣播 \(messageType.rawValue): \(dataSize) bytes → \(connectedPeers.count) 設備")
            
            // 7. 異步並發發送（提高效率）
            Task {
                await withTaskGroup(of: Void.self) { group in
                    for peer in connectedPeers {
                        group.addTask {
                            do {
                                try await self.networkService.send(binaryData, to: [peer])
                            } catch {
                                print("❌ 廣播到 \(peer.displayName) 失敗: \(error)")
                                // 記錄失敗但不阻塞其他發送
                            }
                        }
                    }
                }
            }
            
        } catch {
            print("❌ 廣播編碼失敗: \(error)")
        }
    }
    
    func sendDirectMessage(_ data: Data, to peerID: String, messageType: MeshMessageType) {
        let message = MeshMessage(
            type: messageType,
            sourceID: networkService.myPeerID.displayName,
            targetID: peerID,
            data: data
        )
        
        processOutgoingMessage(message)
        
        // 更新統計
        updateStats(for: message, isSent: true)
        
        print("📤 Sending \(messageType.rawValue) message to \(peerID)")
    }
    
    func getConnectedPeers() -> [String] {
        // 🔧 修復：返回實際連接的設備ID，不是拓撲圖中的所有節點
        return networkService.connectedPeers.map { $0.displayName }
    }
    
    func getNetworkTopology() -> [String: Set<String>] {
        return topology.getConnections()
    }
    
    // MARK: - Emergency Message API
    
    func sendEmergencyMessage(_ data: Data, type: MeshMessageType) {
        guard type.isEmergency else {
            print("❌ Message type \(type.rawValue) is not emergency")
            return
        }
        
        // 檢查自己是否可以發送緊急訊息
        let myPeerID = networkService.myPeerID.displayName
        guard emergencyRateLimiter.shouldAllowEmergencyMessage(from: myPeerID) else {
            print("🚫 Emergency message blocked by rate limiter for self: \(myPeerID)")
            return
        }
        
        broadcastMessage(data, messageType: type)
        print("🚨 Emergency \(type.rawValue) message sent")
    }
    
    
    // MARK: - Advanced Connection Rate Manager API
    
    /// 獲取高級連線速率管理統計
    func getAdvancedConnectionRateStats() -> ConnectionRateStats? {
        return advancedConnectionRateManager?.getStats()
    }
    
    /// 手動封禁節點
    func banPeer(_ peerID: String, duration: TimeInterval? = nil) {
        advancedConnectionRateManager?.banPeer(peerID, duration: duration)
        print("🚫 Manually banned peer: \(peerID)")
    }
    
    /// 解封節點
    func unbanPeer(_ peerID: String) {
        advancedConnectionRateManager?.unbanPeer(peerID)
        print("✅ Manually unbanned peer: \(peerID)")
    }
    
    /// 獲取已封禁的節點
    func getBannedPeers() -> [String: Date] {
        return advancedConnectionRateManager?.getBannedPeers() ?? [:]
    }
    
    /// 獲取節點封禁歷史
    func getBanHistory(for peerID: String) -> Int {
        return advancedConnectionRateManager?.getBanHistory(for: peerID) ?? 0
    }
    
    /// 獲取封禁統計
    func getBanStatistics() -> BanStatistics? {
        return advancedConnectionRateManager?.getBanStatistics()
    }
    
    /// 啟用/停用連線速率保護
    func setConnectionRateProtectionActive(_ active: Bool) {
        advancedConnectionRateManager?.setActive(active)
        print("🛡️ Connection rate protection \(active ? "enabled" : "disabled")")
    }
    
    /// 清除所有封禁
    func clearAllBans() {
        advancedConnectionRateManager?.clearAllBans()
        print("🧹 All bans cleared")
    }
    
    /// 重置連線速率管理統計
    func resetConnectionRateStats() {
        advancedConnectionRateManager?.resetStats()
        print("📊 Connection rate manager stats reset")
    }
    
    // MARK: - Route Management
    
    func updateNodeMetrics(peerID: String, signalStrength: Float, packetLoss: Float) {
        let metrics = SimpleRouteMetrics(
            peerID: peerID,
            signalStrength: signalStrength,
            packetLoss: packetLoss,
            isReachable: true,
            lastHeartbeat: Date()
        )
        
        intelligentRouter.updateNodeMetrics(metrics)
        
        DispatchQueue.main.async {
            self.routingMetrics[peerID] = metrics
        }
    }
    
    func markNodeAsFailed(_ peerID: String) {
        intelligentRouter.markNodeAsFailed(peerID)
        
        // 從拓撲中移除
        topology.removePeer(peerID)
        updateConnectedPeers()
        
        print("🚫 Node \(peerID) marked as failed")
    }
    
    /// 記錄發送失敗，只有在多次失敗後才標記節點為失敗
    private func recordSendFailure(for peerID: String) {
        let now = Date()
        
        // 檢查是否需要重置失敗計數（超過重置間隔）
        if let lastFailure = lastFailureTime[peerID],
           now.timeIntervalSince(lastFailure) > failureResetInterval {
            sendFailureCounts[peerID] = 0
        }
        
        // 增加失敗計數
        sendFailureCounts[peerID, default: 0] += 1
        lastFailureTime[peerID] = now
        
        let failureCount = sendFailureCounts[peerID, default: 0]
        print("⚠️ Send failure for \(peerID): \(failureCount)/\(maxFailureCount)")
        
        // 只有在達到最大失敗次數時才標記為失敗
        if failureCount >= maxFailureCount {
            print("🚫 Node \(peerID) exceeded max failure count, marking as failed")
            markNodeAsFailed(peerID)
            
            // 清理失敗記錄
            sendFailureCounts.removeValue(forKey: peerID)
            lastFailureTime.removeValue(forKey: peerID)
        }
    }
    
    /// 清理成功發送後的失敗記錄
    private func clearSendFailure(for peerID: String) {
        if sendFailureCounts[peerID] != nil {
            sendFailureCounts.removeValue(forKey: peerID)
            lastFailureTime.removeValue(forKey: peerID)
            print("✅ Cleared failure record for \(peerID)")
        }
    }
    
    // MARK: - Private Methods
    
    /// 判斷消息是否需要加密（選擇性加密策略）
    private func shouldEncryptMessage(_ message: MeshMessage) -> Bool {
        // 遊戲消息需要根據具體類型判斷
        if message.type == .game {
            return shouldEncryptGameMessage(message.data)
        }
        
        // 其他消息類型的加密策略
        switch message.type {
        case .chat:
            return true  // 聊天消息始終加密（隱私保護）
        case .signal:
            return false // 信號消息通常是公開資訊
        case .emergency:
            return false // 緊急消息需要快速傳播，不加密
        case .system:
            return true  // 系統消息可能包含敏感資訊
        case .keyExchange, .keyExchangeResponse:
            return false // 密鑰交換本身不需要加密
        case .topology, .routingUpdate:
            return false // 網絡拓撲是公開資訊
        case .heartbeat:
            return false // 心跳消息無敏感資訊
        case .game:
            return false // 遊戲消息已在上面處理，這裡不應該到達
        }
    }
    
    /// 判斷遊戲消息是否需要加密
    private func shouldEncryptGameMessage(_ gameData: Data) -> Bool {
        // 解析遊戲消息類型（第一個字節）
        guard !gameData.isEmpty else { return false }
        
        let gameMessageType = gameData[0]
        
        // 基於您的分析，以下是不需要加密的公開資訊
        switch gameMessageType {
        // 🎯 遊戲核心公開資訊 - 不加密
        case 0x06: // numberDrawn - 抽取號碼（所有人都需要看到）
            return false
        case 0x40: // turnChange - 輪流變更（公平性要求）
            return false
        case 0x09: // gameStart - 遊戲開始（狀態同步）
            return false
        case 0x0A: // gameEnd - 遊戲結束（狀態同步）
            return false
        case 0x0F: // bingoWon - 賓果勝利（公開慶祝）
            return false
        case 0x0C: // emote - 表情（社交互動）
            return false
        case 0x0B: // heartbeat - 心跳（連線信號）
            return false
            
        // 🔐 隱私敏感資訊 - 需要加密
        case 0x01: // playerJoined - 玩家加入（包含設備ID）
            return true
        case 0x02: // playerLeft - 玩家離開（包含設備資訊）
            return true
        case 0x0E: // roomStateUpdate - 房間狀態（可能包含玩家列表）
            return true
        case 0x0D: // roomStateRequest - 房間請求（隱私查詢）
            return true
        case 0x07: // playerProgress - 玩家進度（個人資訊）
            return true
        case 0x08: // chatMessage - 遊戲內聊天（隱私保護）
            return true
            
        // 🤔 其他消息類型預設加密（保守策略）
        default:
            return true
        }
    }
    
    /// 判斷接收到的數據是否為加密消息
    private func isEncryptedMessage(_ data: Data) -> Bool {
        // ChaCha20 加密消息的標識是第一個字節為 0x01
        guard !data.isEmpty else { return false }
        return data[0] == 0x01
    }
    
    private func convertToMeshMessageType(_ extendedType: ExtendedMeshMessageType) -> MeshMessageType {
        switch extendedType {
        case .emergencyMedical, .emergencyDanger:
            return .emergency
        case .signal:
            return .signal
        case .chat:
            return .chat
        case .game:
            return .game
        case .heartbeat:
            return .heartbeat
        case .routingUpdate:
            return .routingUpdate
        case .keyExchange:
            return .keyExchange
        case .system:
            return .system
        }
    }
    
    private func setupNetworkCallbacks() {
        // 🔧 FIX: 移除onDataReceived回調設置，避免與ServiceContainer衝突
        // ServiceContainer現在是唯一的數據處理入口，會分發消息給MeshManager
        // networkService.onDataReceived - 不再設置，由ServiceContainer統一處理
        
        networkService.onPeerConnected = { [weak self] peerID in
            self?.handlePeerConnected(peerID)
        }
        
        networkService.onPeerDisconnected = { [weak self] peerID in
            self?.handlePeerDisconnected(peerID)
        }
    }
    
    private func startServices() {
        isActive = true
        
        // 啟動心跳計時器（修復循環引用）
        heartbeatTimer = Timer.scheduledTimer(withTimeInterval: heartbeatInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.sendHeartbeat()
            }
        }
        
        // 啟動訊息佇列處理（修復循環引用）
        queueProcessingTimer = Timer.scheduledTimer(withTimeInterval: queueProcessingInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.processMessageQueue()
            }
        }
        
        // 啟動清理計時器（修復循環引用）
        metricsCleanupTimer = Timer.scheduledTimer(withTimeInterval: metricsCleanupInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.performCleanup()
            }
        }
        
        print("🚀 MeshManager services started")
    }
    
    private func stopServices() {
        isActive = false
        
        // 線程安全的 Timer 清理
        DispatchQueue.main.async { [weak self] in
            self?.heartbeatTimer?.invalidate()
            self?.heartbeatTimer = nil
            self?.queueProcessingTimer?.invalidate()
            self?.queueProcessingTimer = nil
            self?.metricsCleanupTimer?.invalidate()
            self?.metricsCleanupTimer = nil
        }
        
        messageQueue.clear()
        
        print("🛑 MeshManager services stopped")
    }
    
    private func handleIncomingData(_ data: Data, from peerID: String) async {
        do {
            // 智能解密：先嘗試解析消息類型，再決定是否解密
            let decryptedData: Data
            if isEncryptedMessage(data) {
                let hasKey = await securityService.hasSessionKey(for: peerID)
                if hasKey {
                    decryptedData = try await securityService.decrypt(data, from: peerID)
                    print("🔓 已解密訊息來自: \(peerID)")
                } else {
                    // 加密訊息但無密鑰，可能是隱私訊息傳輸失敗
                    print("⚠️ 收到加密訊息但無密鑰，來自: \(peerID)")
                    decryptedData = data // 嘗試按明文處理
                }
            } else {
                // 明文訊息（公開資訊）
                decryptedData = data
                print("📢 收到明文公開訊息來自: \(peerID)")
            }
            
            // 解析訊息 (使用二進制協議替換JSON) - 增強診斷
            let message: MeshMessage
            do {
                message = try BinaryMessageDecoder.decode(decryptedData)
            } catch {
                // 🔍 詳細診斷失敗的數據
                let analysis = BinaryMessageDecoder.analyzeFailedData(decryptedData)
                print("❌ 解碼失敗詳細分析:")
                print(analysis)
                let hasSessionKey = await securityService.hasSessionKey(for: peerID)
                print("🔍 加密狀態: hasSessionKey = \(hasSessionKey)")
                print("🔍 原始數據大小: \(data.count) bytes")
                print("🔍 解密後數據大小: \(decryptedData.count) bytes")
                
                // 嘗試不同的解碼策略
                if let signalTuple = SignalBinaryCodec.decodeInlineSignalData(decryptedData) {
                    print("✅ 成功解碼為信號數據: 類型=\(signalTuple.type), 設備=\(signalTuple.deviceName)")
                    // 將信號數據轉發到適當的處理器
                    Task {
                        await handleInlineSignalTuple(signalTuple, from: peerID)
                    }
                    return
                }
                
                throw error
            }
            
            // 🛡️ 增強連線速率保護檢查（緊急訊息有專門限制器）
            if !shouldBypassConnectionRateProtection(message: message, from: peerID) {
                if connectionRateManager.shouldBlock(message, from: peerID) {
                    print("🚫 Connection rate protection: Blocked message from \(peerID) (ID: \(message.id), Type: \(message.type.rawValue))")
                    
                    // 記錄攻擊統計
                    networkStats.blockedMessages += 1
                    networkStats.lastBlockedPeer = peerID
                    networkStats.lastBlockedTime = Date()
                    
                    // 記錄到安全日誌
                    Task { @MainActor in
                        ServiceContainer.shared.securityLogManager.logEntry(
                            eventType: "connection_rate_exceeded",
                            source: "MeshManager",
                            severity: SecurityLogSeverity.error,
                            details: "連線速率保護觸發 - PeerID: \(peerID), 訊息類型: \(message.type.rawValue)"
                        )
                    }
                    
                    // 通知安全監控系統
                    Task {
                        await notifySecurityHealthMonitor(
                            event: .connectionRateProtection,
                            peerID: peerID,
                            details: "Message blocked by connection rate protection (Type: \(message.type.rawValue))"
                        )
                    }
                    return
                }
            } else {
                print("🚨 Emergency/System message bypass: \(message.type.rawValue) from \(peerID)")
            }
            
            // 🧠 APT 防禦系統分析（緊急訊息和遊戲訊息繞過）
            if !shouldBypassConnectionRateProtection(message: message, from: peerID) && !isGameCommunication(message: message) {
                let anomalyLevel = await MainActor.run {
                    ServiceContainer.shared.behaviorAnalysisSystem.analyzeMessage(
                        from: peerID,
                        content: String(data: message.data, encoding: .utf8) ?? ""
                    )
                }
                
                if anomalyLevel == .dangerous {
                    print("🛡️ APT Defence: Blocked dangerous connection from \(peerID)")
                    
                    // 記錄統計
                    networkStats.blockedMessages += 1
                    networkStats.lastBlockedPeer = peerID
                    networkStats.lastBlockedTime = Date()
                    
                    // 記錄到安全日誌（已在 BehaviorAnalysisSystem 中自動記錄）
                    
                    return
                } else if anomalyLevel == .suspicious {
                    print("⚠️ Behavior Analysis: Suspicious activity detected from \(peerID) - monitoring")
                }
            } else if isGameCommunication(message: message) {
                print("🎮 遊戲通訊白名單：跳過行為分析 - \(message.type.rawValue) from \(peerID)")
            }
            
            // 重複訊息檢查（線程安全）
            if containsProcessedMessage(message.id) {
                print("🔁 Duplicate message ignored: \(message.id)")
                return
            }
            
            // 記錄已處理訊息（線程安全）
            addToProcessedMessages(message.id)
            
            // 轉換為 ExtendedMeshMessage
            let extendedMessage = ExtendedMeshMessage(
                type: ExtendedMeshMessageType(rawValue: message.type.stringValue) ?? .system,
                sourceID: message.sourceID ?? peerID,
                targetID: message.targetID,
                data: message.data,
                ttl: message.ttl
            )
            
            // 處理訊息
            handleMeshMessage(extendedMessage, from: peerID)
            
            // 呼叫協議回調
            onMessageReceived?(message)
            
            // 更新統計
            updateStats(for: message, isSent: false)
            
        } catch {
            print("❌ Failed to process incoming data from \(peerID): \(error)")
        }
    }
    
    private func handleMeshMessage(_ message: ExtendedMeshMessage, from peerID: String) {
        let myID = networkService.myPeerID.displayName
        
        // 更新節點指標（基於心跳訊息）
        if message.type == .heartbeat {
            updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
        }
        
        // 檢查是否為目標接收者
        if let targetID = message.targetID {
            if targetID == myID {
                // 直接訊息給我
                deliverMessage(message)
                print("📨 Received direct \(message.type.rawValue) from \(message.sourceID)")
            } else {
                // 需要轉發
                forwardMessage(message, from: peerID)
            }
        } else {
            // 廣播訊息
            if message.sourceID != myID {
                deliverMessage(message)
                forwardMessage(message, from: peerID)
                print("📻 Received broadcast \(message.type.rawValue) from \(message.sourceID)")
            }
        }
        
        // 處理特殊訊息類型
        handleSpecialMessageTypes(message, from: peerID)
    }
    
    private func deliverMessage(_ message: ExtendedMeshMessage) {
        // 緊急訊息特殊處理
        if message.type.isEmergency {
            let meshMessageType = convertToMeshMessageType(message.type)
            onEmergencyMessage?(message.data, meshMessageType, message.sourceID)
        }
        
        // 一般訊息處理
        let meshMessage = MeshMessage(type: convertToMeshMessageType(message.type), sourceID: message.sourceID, targetID: message.targetID, data: message.data, ttl: message.ttl)
        onMessageReceived?(meshMessage)
        
        // 【NEW】遊戲訊息特殊處理
        if message.type == .game {
            onGameMessageReceived?(meshMessage)
        }
    }
    
    private func forwardMessage(_ message: ExtendedMeshMessage, from senderID: String) {
        guard message.ttl > 0 && !message.isExpired else {
            print("⚰️ Message expired, not forwarding")
            return
        }
        
        // 避免路由循環
        let myID = networkService.myPeerID.displayName
        if message.routePath.contains(myID) {
            print("🔄 Avoiding routing loop for message \(message.id)")
            return
        }
        
        // 創建轉發副本
        let forwardedMessage = message.forwarded(through: myID)
        
        // 智能轉發決策
        let connectedPeerIDs = networkService.connectedPeers.map { $0.displayName }
        let validTargets = connectedPeerIDs.filter { 
            $0 != senderID && !message.routePath.contains($0) 
        }
        
        if !validTargets.isEmpty {
            let meshMessage = MeshMessage(type: convertToMeshMessageType(forwardedMessage.type), sourceID: forwardedMessage.sourceID, targetID: forwardedMessage.targetID, data: forwardedMessage.data, ttl: forwardedMessage.ttl)
            messageQueue.enqueue(meshMessage)
            
            // 更新轉發統計
            DispatchQueue.main.async {
                self.networkStats.messagesForwarded += 1
            }
            
            print("🔄 Queued message for forwarding to \(validTargets.count) peers")
        }
    }
    
    private func processOutgoingMessage(_ message: MeshMessage) {
        messageQueue.enqueue(message)
    }
    
    private func processMessageQueue() {
        guard let message = messageQueue.dequeue() else { return }
        
        if let targetID = message.targetID {
            // 直接訊息 - 使用智能路由
            routeDirectMessage(message, to: targetID)
        } else {
            // 廣播訊息
            broadcastToConnectedPeers(message)
        }
    }
    
    private func routeDirectMessage(_ message: MeshMessage, to targetID: String) {
        let myID = networkService.myPeerID.displayName
        let connectedPeers = networkService.connectedPeers
        
        // 檢查是否直接連接
        if let targetPeer = connectedPeers.first(where: { $0.displayName == targetID }) {
            sendMessageToPeer(message, peer: targetPeer)
            return
        }
        
        // 使用智能路由尋找最佳路徑
        if let route = intelligentRouter.findBestRoute(
            from: myID, 
            to: targetID, 
            topology: topology, 
            isEmergency: message.type.isEmergency
        ) {
            if route.count > 1 {
                let nextHop = route[1]
                if let peer = connectedPeers.first(where: { $0.displayName == nextHop }) {
                    sendMessageToPeer(message, peer: peer)
                    print("🛤️ Routed \(message.type.isEmergency ? "EMERGENCY " : "")\(message.type.rawValue) to \(targetID) via \(nextHop)")
                    return
                }
            }
        }
        
        print("🚫 No route found to \(targetID)")
    }
    
    private func broadcastToConnectedPeers(_ message: MeshMessage) {
        let connectedPeers = networkService.connectedPeers
        
        for peer in connectedPeers {
            // 避免回傳給原始發送者
            if !message.routePath.contains(peer.displayName) {
                sendMessageToPeer(message, peer: peer)
            }
        }
    }
    
    private func sendMessageToPeer(_ message: MeshMessage, peer: MCPeerID) {
        Task {
            do {
                let messageData = try BinaryMessageEncoder.encode(message)
                
                // 選擇性加密：公開資訊不加密，隱私資訊條件加密
                let finalData: Data
                if shouldEncryptMessage(message) {
                    let hasKey = await securityService.hasSessionKey(for: peer.displayName)
                    if hasKey {
                        finalData = try await securityService.encrypt(messageData, for: peer.displayName)
                        print("🔐 已加密傳送: \(message.type.stringValue) 到 \(peer.displayName)")
                    } else {
                        finalData = messageData
                        print("⚠️ 無密鑰，明文傳送隱私訊息: \(message.type.stringValue)")
                    }
                } else {
                    finalData = messageData
                    print("📢 公開資訊明文傳送: \(message.type.stringValue)")
                }
                
                try await networkService.send(finalData, to: [peer])
                
                // 發送成功，清理失敗記錄
                clearSendFailure(for: peer.displayName)
                
            } catch {
                print("❌ Failed to send message to \(peer.displayName): \(error)")
                
                // 記錄發送失敗，但不立即標記為失敗
                recordSendFailure(for: peer.displayName)
            }
        }
    }
    
    private func handleSpecialMessageTypes(_ message: ExtendedMeshMessage, from peerID: String) {
        switch message.type {
        case .heartbeat:
            handleHeartbeat(message, from: peerID)
        case .routingUpdate:
            handleRoutingUpdate(message, from: peerID)
        case .keyExchange:
            let meshMessage = MeshMessage(type: convertToMeshMessageType(message.type), sourceID: message.sourceID, targetID: message.targetID, data: message.data, ttl: message.ttl)
            handleKeyExchange(meshMessage, from: peerID)
        default:
            break
        }
    }
    
    private func handleHeartbeat(_ message: ExtendedMeshMessage, from peerID: String) {
        // 更新拓撲連接
        topology.addConnection(from: message.sourceID, to: peerID)
        updateConnectedPeers()
        
        // 更新節點指標
        updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
    }
    
    // MARK: - 🚨 信號數據處理
    private func handleInlineSignalTuple(_ signalTuple: (type: SignalType, deviceName: String, deviceID: String, gridCode: String?, timestamp: Date), from peerID: String) async {
        print("🚨 處理內聯信號數據: 類型=\(signalTuple.type), 來源=\(signalTuple.deviceName)")
        
        // 轉發到 ServiceContainer 的信號處理系統
        await MainActor.run {
            _ = Task {
                await ServiceContainer.shared.routeInlineSignalTuple(signalTuple, from: peerID)
            }
        }
        
        // 更新統計數據
        networkStats.messagesReceived += 1
        
        // 記錄成功處理
        print("✅ 內聯信號數據處理完成")
    }
    
    private func handleRoutingUpdate(_ message: ExtendedMeshMessage, from peerID: String) {
        do {
            let remoteTopology = try BinaryMessageDecoder.decodeTopology(message.data, expectedType: .routingUpdate)
            
            // 合併拓撲信息
            for (node, connections) in remoteTopology {
                for connection in connections {
                    topology.addConnection(from: node, to: connection)
                }
            }
            
            updateConnectedPeers()
            
        } catch {
            print("❌ Failed to process routing update from \(peerID): \(error)")
        }
    }
    
    private func handleKeyExchange(_ message: MeshMessage, from peerID: String) {
        print("🔑 收到來自 \(peerID) 的密鑰交換請求")
        
        // 轉發給 ServiceContainer 使用原有的密鑰交換處理邏輯
        Task { @MainActor in
            await ServiceContainer.shared.handleKeyExchangeMessage(message)
        }
    }
    
    private func handlePeerConnected(_ peerID: String) {
        // 🧠 APT 防禦系統分析新連接
        let anomalyLevel = ServiceContainer.shared.behaviorAnalysisSystem.analyzeConnection(from: peerID)
        
        if anomalyLevel == .dangerous {
            print("🛡️ APT Defence: Blocked dangerous peer connection - \(peerID)")
            
            // 記錄統計
            networkStats.blockedConnections += 1
            ServiceContainer.shared.behaviorAnalysisSystem.blockedConnections += 1
            
            // 註記：危險連接將被監控，實際斷開需要更複雜的peer管理
            // TODO: 實作真正的連接斷開機制
            
            return
        } else if anomalyLevel == .suspicious {
            print("⚠️ APT Defence: Suspicious peer connected - \(peerID) - monitoring")
        }
        
        topology.addConnection(from: networkService.myPeerID.displayName, to: peerID)
        updateConnectedPeers()
        sendRoutingUpdate()
        
        // 初始化節點指標
        updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
        
        // 1. 報告對等體連接到網格層
        networkStateCoordinator.reportPeerConnection(peerID, connected: true, layer: .mesh)
        
        // 2. 檢查並更新網格層狀態
        let currentPeerCount = getConnectedPeers().count
        if currentPeerCount > 0 {
            networkStateCoordinator.reportMeshLayerState(.ready, peerCount: currentPeerCount)
        }
        
        // 🔑 主動啟動密鑰交換以提高穩定性
        Task { @MainActor in
            // 短暫延遲以確保連接穩定
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5秒延遲
            
            // 檢查連接是否仍然活躍
            if getConnectedPeers().contains(peerID) {
                print("🔑 主動啟動與 \(peerID) 的密鑰交換")
                await ServiceContainer.shared.scheduleKeyExchangeRetry(with: peerID)
            }
        }
        
        // 呼叫協議回調
        onPeerConnected?(peerID)
        
        print("🤝 Peer connected: \(peerID)")
    }
    
    private func handlePeerDisconnected(_ peerID: String) {
        topology.removePeer(peerID)
        Task {
            await securityService.removeSessionKey(for: peerID)
        }
        intelligentRouter.markNodeAsFailed(peerID)
        
        // 清理密鑰交換狀態
        ServiceContainer.shared.cleanupKeyExchangeState(for: peerID)
        
        updateConnectedPeers()
        sendRoutingUpdate()
        
        // 1. 報告對等體斷開連接
        networkStateCoordinator.reportPeerConnection(peerID, connected: false, layer: .mesh)
        
        // 2. 檢查並更新網格層狀態
        let remainingPeerCount = getConnectedPeers().count
        if remainingPeerCount == 0 {
            networkStateCoordinator.reportMeshLayerState(.disconnected, peerCount: 0)
        } else {
            networkStateCoordinator.reportMeshLayerState(.ready, peerCount: remainingPeerCount)
        }
        
        // 清理指標
        DispatchQueue.main.async {
            self.routingMetrics.removeValue(forKey: peerID)
        }
        
        // 呼叫協議回調
        onPeerDisconnected?(peerID)
        
        print("👋 Peer disconnected: \(peerID)")
    }
    
    private func updateConnectedPeers() {
        DispatchQueue.main.async {
            self.connectedPeers = self.getConnectedPeers()
            self.networkStats.connectedPeersCount = self.connectedPeers.count
            self.onNetworkTopologyChanged?(self.getNetworkTopology())
        }
    }
    
    private func sendHeartbeat() {
        // 🚨 災難通信優化：智能心跳管理
        let connectedCount = networkService.connectedPeers.count
        
        // 1. 如果沒有連接，不發送心跳節省資源
        guard connectedCount > 0 else {
            print("📱 無連接設備，跳過心跳")
            return
        }
        
        // 2. 創建輕量級心跳數據（包含基本拓撲信息）
        let myID = networkService.myPeerID.displayName
        let heartbeatInfo = "\(myID):\(connectedCount)"
        let heartbeatData = heartbeatInfo.data(using: .utf8) ?? Data()
        
        print("💓 發送心跳到 \(connectedCount) 個設備")
        broadcastMessage(heartbeatData, messageType: .heartbeat)
    }
    
    private func sendRoutingUpdate() {
        do {
            let topologyDict = Dictionary(uniqueKeysWithValues: topology.getConnections().map { (key, value) in
                (key, Set(value))
            })
            let topologyData = try BinaryMessageEncoder.encodeTopology(topologyDict, messageType: .routingUpdate)
            broadcastMessage(topologyData, messageType: .routingUpdate)
        } catch {
            print("❌ Failed to send routing update: \(error)")
        }
    }
    
    private func updateStats(for message: MeshMessage, isSent: Bool) {
        DispatchQueue.main.async {
            if isSent {
                self.networkStats.messagesSent += 1
                if message.type.isEmergency {
                    self.networkStats.emergencyMessagesSent += 1
                }
            } else {
                self.networkStats.messagesReceived += 1
                if message.type.isEmergency {
                    self.networkStats.emergencyMessagesReceived += 1
                }
            }
        }
    }
    
    // 線程安全的 processedMessages 管理方法
    private func containsProcessedMessage(_ messageID: String) -> Bool {
        return processedMessagesQueue.sync {
            _processedMessages.contains(messageID)
        }
    }
    
    private func addToProcessedMessages(_ messageID: String) {
        Task { @MainActor in
            self._processedMessages.insert(messageID)
            
            // 限制記憶體使用 - LRU 清理策略
            if self._processedMessages.count > self.processedMessagesLimit {
                let excess = self._processedMessages.count - self.processedMessagesLimit / 2
                let toRemove = Array(self._processedMessages.prefix(excess))
                
                for id in toRemove {
                    self._processedMessages.remove(id)
                }
                
                print("🧩 Cleaned \(excess) old processed messages")
            }
        }
    }
    
    private func clearProcessedMessages() {
        Task { @MainActor in
            self._processedMessages.removeAll()
        }
    }
    
    private func performCleanup() {
        // 清理智能路由器
        intelligentRouter.cleanup()
        
        // 清理緊急訊息速率限制器
        emergencyRateLimiter.performCleanup()
        
        // 更新網路可靠性統計
        updateNetworkReliability()
        
        print("🧹 Performed periodic cleanup")
    }
    
    private func updateNetworkReliability() {
        let allMetrics = intelligentRouter.getAllNodeMetrics()
        let activeNodes = allMetrics.values.filter { $0.isReachable }
        
        if !activeNodes.isEmpty {
            let averageScore = activeNodes.reduce(0.0) { $0 + $1.routeScore } / Float(activeNodes.count)
            
            DispatchQueue.main.async {
                self.networkStats.networkReliability = averageScore
            }
        }
    }
}

// MARK: - String Extension for Repetition
extension String {
    static func * (left: String, right: Int) -> String {
        return String(repeating: left, count: right)
    }
}

// MARK: - Backward Compatibility API
extension MeshManager {
    // 向後兼容的API方法，讓舊的ViewModel能夠正常工作
    
    /// 向後兼容的簡單初始化器
    convenience init() {
        // 創建簡單的實現作為替代
        let dummyNetworkService = DummyNetworkService()
        let _ = DummySecurityService() // 用於向後兼容性
        
        // 使用高級連線速率管理作為默認選項
        let advancedProtection = ConnectionRateManager()
        
        self.init(
            networkService: dummyNetworkService,
            securityService: SecurityService(),
            trustScoreManager: TrustScoreManager(),
            connectionRateManager: nil,
            advancedConnectionRateManager: advancedProtection
        )
        print("🕸️ MeshManager initialized with dummy services and advanced connection rate manager (backward compatibility)")
    }
    
    /// 啟動Mesh網路（兼容舊API）
    func startMeshNetworkLegacy() {
        // 新版本在初始化時自動啟動，這裡只是記錄
        print("🕸️ MeshManager: Legacy startMeshNetwork() called")
    }
    
    
    /// 設置訊息處理器（兼容舊API）
    func setMessageHandler(_ handler: @escaping (Data) -> Void) {
        onMessageReceived = { message in
            handler(message.data)
        }
        print("🕸️ MeshManager: Legacy message handler set")
    }
    
    /// 廣播訊息（兼容舊API）
    func broadcast(_ data: Data, priority: MessagePriority, userNickname: String) async throws {
        // 將舊的優先級映射到新的訊息類型
        let messageType: MeshMessageType
        switch priority {
        case .emergency:
            messageType = .emergency  // 緊急訊息
        case .high:
            messageType = .signal
        case .normal:
            messageType = .chat
        case .low:
            messageType = .system
        }
        
        broadcastMessage(data, messageType: messageType)
        print("🕸️ MeshManager: Legacy broadcast called with priority \(priority)")
    }
}

// MARK: - Dummy Implementations for Backward Compatibility
@MainActor
class DummyNetworkService: NetworkServiceProtocol {
    var isConnected: Bool = false
    var myPeerID: MCPeerID = MCPeerID(displayName: "DummyPeer")
    var connectedPeers: [MCPeerID] = []
    var onDataReceived: ((Data, String) -> Void)?
    var onPeerConnected: ((String) -> Void)?
    var onPeerDisconnected: ((String) -> Void)?
    
    func startNetworking() {
        print("🔧 DummyNetworkService: startNetworking called (no-op)")
    }
    
    func stopNetworking() {
        print("🔧 DummyNetworkService: stopNetworking called (no-op)")
    }
    
    func send(_ data: Data, to peers: [MCPeerID]) async throws {
        print("🔧 DummyNetworkService: send called (no-op)")
    }
}

class DummySecurityService: SecurityServiceProtocol {
    func generateSessionKey() -> Data? { return Data() }
    func encryptData(_ data: Data) -> Data? { return data }
    func decryptData(_ data: Data) -> Data? { return data }
    func hasSessionKey(for peerID: String) async -> Bool { return false }
    func encrypt(_ data: Data, for peerID: String) throws -> Data { return data }
    func decrypt(_ data: Data, from peerID: String) throws -> Data { return data }
    func getPublicKey() throws -> Data { return Data() }
    func removeSessionKey(for peerID: String) {}
} 
