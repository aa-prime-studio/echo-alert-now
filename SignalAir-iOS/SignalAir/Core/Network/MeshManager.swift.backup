import Foundation
import Combine
import MultipeerConnectivity

// MARK: - ç¶²çµ¡é€£æ¥ç‹€æ…‹çµ±ä¸€å®šç¾©
enum NetworkConnectionState: String, CaseIterable {
    case disconnected = "disconnected"      // å®Œå…¨æ–·ç·š
    case connecting = "connecting"          // æ­£åœ¨é€£æ¥
    case connected = "connected"            // å·²é€£æ¥ä½†æœªå°±ç·’
    case ready = "ready"                   // å®Œå…¨å°±ç·’ï¼ˆåŒ…å«å¯†é‘°äº¤æ›ï¼‰
    case reconnecting = "reconnecting"      // é‡æ–°é€£æ¥ä¸­
    case failed = "failed"                 // é€£æ¥å¤±æ•—
    
    var isActive: Bool {
        return self == .connected || self == .ready
    }
    
    var canSendMessages: Bool {
        return self == .ready
    }
    
    var displayName: String {
        switch self {
        case .disconnected: return "é›¢ç·š"
        case .connecting: return "é€£æ¥ä¸­"
        case .connected: return "å·²é€£æ¥"
        case .ready: return "å°±ç·’"
        case .reconnecting: return "é‡æ–°é€£æ¥"
        case .failed: return "é€£æ¥å¤±æ•—"
        }
    }
}

// MARK: - ç¶²çµ¡å±¤ç´šå®šç¾©
enum NetworkLayer: String, CaseIterable {
    case physical = "physical"      // ç‰©ç†å±¤ (NetworkService)
    case mesh = "mesh"             // ç¶²æ ¼å±¤ (MeshManager)
    case application = "application" // æ‡‰ç”¨å±¤ (BingoNetworkManager)
    
    var priority: Int {
        switch self {
        case .physical: return 3      // æœ€é«˜å„ªå…ˆç´š
        case .mesh: return 2
        case .application: return 1   // æœ€ä½å„ªå…ˆç´š
        }
    }
}

// MARK: - ç¶²çµ¡ç‹€æ…‹å ±å‘Š
struct NetworkLayerState {
    let layer: NetworkLayer
    let state: NetworkConnectionState
    let peerCount: Int
    let lastUpdate: Date
    let metadata: [String: Any]
    
    init(layer: NetworkLayer, state: NetworkConnectionState, peerCount: Int = 0, metadata: [String: Any] = [:]) {
        self.layer = layer
        self.state = state
        self.peerCount = peerCount
        self.lastUpdate = Date()
        self.metadata = metadata
    }
}

// MARK: - çµ±ä¸€ç¶²çµ¡ç‹€æ…‹å”èª¿å™¨
@MainActor
class NetworkStateCoordinator: ObservableObject {
    
    // MARK: - Singleton
    static let shared = NetworkStateCoordinator()
    
    // MARK: - Published Properties
    @Published private(set) var overallState: NetworkConnectionState = .disconnected
    @Published private(set) var layerStates: [NetworkLayer: NetworkLayerState] = [:]
    @Published private(set) var connectedPeers: Set<String> = []
    @Published private(set) var activePeerCount: Int = 0
    @Published private(set) var isStable: Bool = false
    @Published private(set) var lastStateChange: Date = Date()
    
    // MARK: - State Publishers
    private let stateChangeSubject = PassthroughSubject<NetworkConnectionState, Never>()
    private let layerStateSubject = PassthroughSubject<NetworkLayerState, Never>()
    
    var stateChanges: AnyPublisher<NetworkConnectionState, Never> {
        stateChangeSubject.eraseToAnyPublisher()
    }
    
    var layerStateChanges: AnyPublisher<NetworkLayerState, Never> {
        layerStateSubject.eraseToAnyPublisher()
    }
    
    // MARK: - Internal State
    private var stateHistory: [NetworkConnectionState] = []
    private let maxHistorySize = 10
    private var stabilityTimer: Timer?
    private let stabilityThreshold: TimeInterval = 5.0 // 5ç§’ç©©å®šæ‰ç®—çœŸæ­£ç©©å®š
    
    // MARK: - Thread-Safe State Access
    private let stateQueue = DispatchQueue(label: "com.signalair.networkstate", attributes: .concurrent)
    private var _internalStates: [NetworkLayer: NetworkLayerState] = [:]
    
    private var internalStates: [NetworkLayer: NetworkLayerState] {
        get {
            return stateQueue.sync { _internalStates }
        }
        set {
            stateQueue.async(flags: .barrier) { [weak self] in
                self?._internalStates = newValue
            }
        }
    }
    
    // MARK: - Initialization
    private init() {
        setupStabilityMonitoring()
        print("ğŸ”— NetworkStateCoordinator: åˆå§‹åŒ–å®Œæˆ")
    }
    
    // MARK: - Public API - Layer State Reporting
    
    /// å ±å‘Šå±¤ç´šç‹€æ…‹æ›´æ–°
    func reportLayerState(_ layer: NetworkLayer, state: NetworkConnectionState, peerCount: Int = 0, metadata: [String: Any] = [:]) {
        let layerState = NetworkLayerState(layer: layer, state: state, peerCount: peerCount, metadata: metadata)
        
        // ç·šç¨‹å®‰å…¨æ›´æ–°
        var currentStates = internalStates
        currentStates[layer] = layerState
        internalStates = currentStates
        
        // ä¸»ç·šç¨‹æ›´æ–°ç™¼å¸ƒå±¬æ€§
        layerStates[layer] = layerState
        
        // é‡æ–°è¨ˆç®—æ•´é«”ç‹€æ…‹
        calculateOverallState()
        
        // ç™¼å¸ƒå±¤ç´šç‹€æ…‹è®Šæ›´
        layerStateSubject.send(layerState)
        
        print("ğŸ”— NetworkStateCoordinator: \(layer.rawValue) å±¤å ±å‘Šç‹€æ…‹ \(state.rawValue) (å°ç­‰é«”: \(peerCount))")
    }
    
    /// å ±å‘Šå°ç­‰é«”é€£æ¥è®Šæ›´
    func reportPeerConnection(_ peerID: String, connected: Bool, layer: NetworkLayer) {
        if connected {
            connectedPeers.insert(peerID)
        } else {
            connectedPeers.remove(peerID)
        }
        
        activePeerCount = connectedPeers.count
        
        // æ›´æ–°å°æ‡‰å±¤ç´šçš„å°ç­‰é«”æ•¸é‡
        if let layerState = layerStates[layer] {
            let updatedState = NetworkLayerState(
                layer: layer,
                state: layerState.state,
                peerCount: connected ? layerState.peerCount + 1 : max(0, layerState.peerCount - 1),
                metadata: layerState.metadata
            )
            reportLayerState(layer, state: layerState.state, peerCount: updatedState.peerCount, metadata: layerState.metadata)
        }
        
        print("ğŸ”— NetworkStateCoordinator: å°ç­‰é«” \(peerID) \(connected ? "é€£æ¥" : "æ–·é–‹") (\(layer.rawValue) å±¤)")
    }
    
    // MARK: - State Calculation
    
    /// è¨ˆç®—æ•´é«”ç¶²çµ¡ç‹€æ…‹ï¼ˆåŸºæ–¼æ‰€æœ‰å±¤ç´šç‹€æ…‹ï¼‰
    private func calculateOverallState() {
        let states = Array(layerStates.values)
        
        // å¦‚æœæ²’æœ‰ä»»ä½•å±¤ç´šå ±å‘Šï¼Œä¿æŒæ–·ç·šç‹€æ…‹
        guard !states.isEmpty else {
            updateOverallState(.disconnected)
            return
        }
        
        // æª¢æŸ¥å„å±¤ç´šç‹€æ…‹
        let physicalState = layerStates[.physical]?.state ?? .disconnected
        let meshState = layerStates[.mesh]?.state ?? .disconnected
        let applicationState = layerStates[.application]?.state ?? .disconnected
        
        let newState: NetworkConnectionState
        
        // ç‹€æ…‹è¨ˆç®—é‚è¼¯ï¼šå¿…é ˆæ‰€æœ‰å±¤ç´šéƒ½æ­£å¸¸æ‰ç®—æ­£å¸¸
        if physicalState == .failed || meshState == .failed || applicationState == .failed {
            newState = .failed
        } else if physicalState == .reconnecting || meshState == .reconnecting || applicationState == .reconnecting {
            newState = .reconnecting
        } else if physicalState == .connecting || meshState == .connecting || applicationState == .connecting {
            newState = .connecting
        } else if physicalState == .ready && meshState == .ready && applicationState == .ready {
            newState = .ready
        } else if physicalState.isActive && meshState.isActive && applicationState.isActive {
            newState = .connected
        } else {
            newState = .disconnected
        }
        
        updateOverallState(newState)
    }
    
    /// æ›´æ–°æ•´é«”ç‹€æ…‹
    private func updateOverallState(_ newState: NetworkConnectionState) {
        guard newState != overallState else { return }
        
        let previousState = overallState
        overallState = newState
        lastStateChange = Date()
        
        // æ›´æ–°ç‹€æ…‹æ­·å²
        stateHistory.append(newState)
        if stateHistory.count > maxHistorySize {
            stateHistory.removeFirst()
        }
        
        // é‡ç½®ç©©å®šæ€§è¨ˆæ™‚å™¨
        resetStabilityTimer()
        
        // ç™¼å¸ƒç‹€æ…‹è®Šæ›´
        stateChangeSubject.send(newState)
        
        print("ğŸ”— NetworkStateCoordinator: æ•´é«”ç‹€æ…‹è®Šæ›´ \(previousState.rawValue) â†’ \(newState.rawValue)")
    }
    
    // MARK: - Stability Monitoring
    
    /// è¨­ç½®ç©©å®šæ€§ç›£æ§
    private func setupStabilityMonitoring() {
        // ç©©å®šæ€§æª¢æŸ¥å°‡åœ¨ç‹€æ…‹è®Šæ›´æ™‚é‡ç½®
    }
    
    /// é‡ç½®ç©©å®šæ€§è¨ˆæ™‚å™¨
    private func resetStabilityTimer() {
        stabilityTimer?.invalidate()
        isStable = false
        
        stabilityTimer = Timer.scheduledTimer(withTimeInterval: stabilityThreshold, repeats: false) { [weak self] _ in
            Task { @MainActor in
                self?.markAsStable()
            }
        }
    }
    
    /// æ¨™è¨˜ç‚ºç©©å®šç‹€æ…‹
    private func markAsStable() {
        isStable = true
        print("ğŸ”— NetworkStateCoordinator: ç¶²çµ¡ç‹€æ…‹å·²ç©©å®š (\(overallState.rawValue))")
    }
    
    // MARK: - Convenience Extensions
    
    /// å¿«é€Ÿå ±å‘Šç‰©ç†å±¤ç‹€æ…‹
    func reportPhysicalLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.physical, state: state, peerCount: peerCount)
    }
    
    /// å¿«é€Ÿå ±å‘Šç¶²æ ¼å±¤ç‹€æ…‹
    func reportMeshLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.mesh, state: state, peerCount: peerCount)
    }
    
    /// å¿«é€Ÿå ±å‘Šæ‡‰ç”¨å±¤ç‹€æ…‹
    func reportApplicationLayerState(_ state: NetworkConnectionState, peerCount: Int = 0) {
        reportLayerState(.application, state: state, peerCount: peerCount)
    }
    
    // MARK: - Cleanup
    deinit {
        stabilityTimer?.invalidate()
        print("ğŸ”— NetworkStateCoordinator: å·²æ¸…ç†")
    }
}

// MARK: - Message Priority
enum MessagePriority: String, CaseIterable, Codable {
    case low = "low"
    case normal = "normal"
    case high = "high"
    case emergency = "emergency"
}

// MARK: - Mesh Network Protocol
@MainActor
protocol MeshNetworkProtocol {
    func broadcastMessage(_ data: Data, messageType: MeshMessageType)
    func sendDirectMessage(_ data: Data, to peerID: String, messageType: MeshMessageType)
    func getConnectedPeers() -> [String]
    func getNetworkTopology() -> [String: Set<String>]
}

// MARK: - Extended Message Types with Emergency Priority
enum ExtendedMeshMessageType: String, CaseIterable, Codable {
    case emergencyMedical = "emergency_medical"  // æœ€é«˜å„ªå…ˆç´š
    case emergencyDanger = "emergency_danger"    // æœ€é«˜å„ªå…ˆç´š
    case signal = "signal"
    case chat = "chat"
    case game = "game"
    case heartbeat = "heartbeat"
    case routingUpdate = "routing_update"
    case keyExchange = "key_exchange"
    case system = "system"
    
    var priority: Int {
        switch self {
        case .emergencyMedical: return 100  // ç·Šæ€¥é†«ç™‚æ±‚åŠ©
        case .emergencyDanger: return 100   // ç·Šæ€¥å±éšªè­¦å ±
        case .signal: return 10
        case .keyExchange: return 9
        case .system: return 8
        case .heartbeat: return 7
        case .routingUpdate: return 6
        case .chat: return 5
        case .game: return 4
        }
    }
    
    var isEmergency: Bool {
        return self == .emergencyMedical || self == .emergencyDanger
    }
}

// MARK: - Simple Route Quality (ç°¡åŒ–çš„è·¯ç”±å“è³ª)
struct SimpleRouteMetrics: Codable {
    let peerID: String
    var signalStrength: Float = -50.0        // -100 åˆ° 0 dBmï¼Œè¶Šæ¥è¿‘0è¶Šå¥½
    var packetLoss: Float = 0.0              // 0.0-1.0ï¼Œè¶Šä½è¶Šå¥½
    var isReachable: Bool = true             // æ˜¯å¦å¯é”
    var lastHeartbeat: Date = Date()         // æœ€å¾Œå¿ƒè·³æ™‚é–“
    
    // ç°¡å–®çš„è·¯ç”±è©•åˆ†ï¼ˆ0.0-1.0ï¼‰
    var routeScore: Float {
        guard isReachable else { return 0.0 }
        
        // æª¢æŸ¥æ˜¯å¦è¶…æ™‚ï¼ˆè¶…é60ç§’æ²’å¿ƒè·³è¦–ç‚ºä¸å¯é”ï¼‰
        if Date().timeIntervalSince(lastHeartbeat) > 60.0 {
            return 0.0
        }
        
        // ä¿¡è™Ÿå¼·åº¦è©•åˆ†ï¼š-100dBm=0åˆ†ï¼Œ-50dBm=1åˆ†
        let signalScore = max(0.0, min(1.0, (signalStrength + 100.0) / 50.0))
        
        // ä¸ŸåŒ…ç‡è©•åˆ†ï¼š0%ä¸ŸåŒ…=1åˆ†ï¼Œ100%ä¸ŸåŒ…=0åˆ†
        let lossScore = max(0.0, 1.0 - packetLoss)
        
        // ç°¡å–®åŠ æ¬Šï¼šä¿¡è™Ÿå¼·åº¦60%ï¼Œä¸ŸåŒ…ç‡40%
        return signalScore * 0.6 + lossScore * 0.4
    }
    
    var isStale: Bool {
        return Date().timeIntervalSince(lastHeartbeat) > 60.0
    }
}

// MARK: - Emergency Route Cache (ç·Šæ€¥è·¯ç”±å¿«å–)
class EmergencyRouteCache {
    private var metrics: [String: SimpleRouteMetrics] = [:]
    private var emergencyPaths: [String: [String]] = [:]  // å¿«å–ç·Šæ€¥è·¯å¾‘
    private let lock = NSLock()
    
    func updateMetrics(_ metrics: SimpleRouteMetrics) {
        lock.lock()
        defer { lock.unlock() }
        
        self.metrics[metrics.peerID] = metrics
        
        // æ¸…ç†å¤±æ•ˆçš„ç¯€é»
        self.metrics = self.metrics.filter { !$0.value.isStale }
    }
    
    func getMetrics(for peerID: String) -> SimpleRouteMetrics? {
        lock.lock()
        defer { lock.unlock() }
        
        return metrics[peerID]
    }
    
    func cacheEmergencyPath(to destination: String, path: [String]) {
        lock.lock()
        defer { lock.unlock() }
        
        emergencyPaths[destination] = path
    }
    
    func getEmergencyPath(to destination: String) -> [String]? {
        lock.lock()
        defer { lock.unlock() }
        
        return emergencyPaths[destination]
    }
    
    func clearStaleData() {
        lock.lock()
        defer { lock.unlock() }
        
        metrics = metrics.filter { !$0.value.isStale }
        
        // æ¸…ç†ç„¡æ•ˆçš„ç·Šæ€¥è·¯å¾‘
        for (destination, path) in emergencyPaths {
            for nodeID in path {
                if let nodeMetrics = metrics[nodeID], !nodeMetrics.isReachable {
                    emergencyPaths.removeValue(forKey: destination)
                    break
                }
            }
        }
    }
    
    func getAllMetrics() -> [String: SimpleRouteMetrics] {
        lock.lock()
        defer { lock.unlock() }
        
        return metrics
    }
}

// MARK: - Simple Intelligent Router (ç°¡åŒ–æ™ºèƒ½è·¯ç”±å™¨)
class SimpleIntelligentRouter {
    private let routeCache = EmergencyRouteCache()
    private var failedNodes: Set<String> = []
    private let lock = NSLock()
    
    // å°‹æ‰¾æœ€ä½³è·¯ç”±ï¼ˆå„ªå…ˆè€ƒæ…®ç·Šæ€¥è¨Šæ¯ï¼‰
    func findBestRoute(from source: String, to destination: String, 
                      topology: LocalNetworkTopology, isEmergency: Bool = false) -> [String]? {
        
        // 1. å¦‚æœæ˜¯ç·Šæ€¥è¨Šæ¯ï¼Œå…ˆæª¢æŸ¥å¿«å–çš„ç·Šæ€¥è·¯å¾‘
        if isEmergency, let emergencyPath = routeCache.getEmergencyPath(to: destination) {
            if isPathValid(emergencyPath) {
                return emergencyPath
            }
        }
        
        // 2. å°‹æ‰¾æ‰€æœ‰å¯èƒ½è·¯å¾‘
        let availablePaths = findMultiplePaths(from: source, to: destination, topology: topology)
        
        // 3. è©•ä¼°è·¯å¾‘ä¸¦é¸æ“‡æœ€ä½³çš„
        let bestPath = selectBestPath(availablePaths, isEmergency: isEmergency)
        
        // 4. å¦‚æœæ˜¯ç·Šæ€¥è¨Šæ¯ï¼Œå¿«å–æœ€ä½³è·¯å¾‘
        if isEmergency, let path = bestPath {
            routeCache.cacheEmergencyPath(to: destination, path: path)
        }
        
        return bestPath
    }
    
    // å°‹æ‰¾å¤šæ¢è·¯å¾‘ï¼ˆæœ€å¤š3æ¢ï¼Œé¿å…éåº¦è¨ˆç®—ï¼‰
    private func findMultiplePaths(from source: String, to destination: String, 
                                  topology: LocalNetworkTopology) -> [[String]] {
        var paths: [[String]] = []
        var excludeNodes: Set<String> = failedNodes
        
        // æœ€å¤šæ‰¾3æ¢è·¯å¾‘
        for _ in 0..<3 {
            if let path = topology.findRoute(from: source, to: destination, excluding: excludeNodes) {
                paths.append(path)
                
                // æ’é™¤æ­¤è·¯å¾‘çš„ä¸­é–“ç¯€é»ä»¥æ‰¾åˆ°ä¸åŒè·¯å¾‘
                if path.count > 2 {
                    for node in path[1..<path.count-1] {
                        excludeNodes.insert(node)
                    }
                }
            } else {
                break
            }
        }
        
        return paths
    }
    
    // é¸æ“‡æœ€ä½³è·¯å¾‘ï¼ˆç°¡å–®ä½†æœ‰æ•ˆï¼‰
    private func selectBestPath(_ paths: [[String]], isEmergency: Bool) -> [String]? {
        guard !paths.isEmpty else { return nil }
        
        // ç·Šæ€¥è¨Šæ¯ï¼šé¸æ“‡æœ€çŸ­ä¸”æœ€å¯é çš„è·¯å¾‘
        if isEmergency {
            return paths.min { path1, path2 in
                let score1 = calculatePathReliability(path1)
                let score2 = calculatePathReliability(path2)
                
                // å¦‚æœå¯é æ€§ç›¸è¿‘ï¼Œé¸æ“‡è¼ƒçŸ­çš„è·¯å¾‘
                if abs(score1 - score2) < 0.1 {
                    return path1.count < path2.count
                }
                return score1 > score2
            }
        }
        
        // ä¸€èˆ¬è¨Šæ¯ï¼šç¶œåˆè€ƒæ…®è·¯å¾‘å“è³ªå’Œè·³æ•¸
        return paths.max { path1, path2 in
            let score1 = calculatePathScore(path1)
            let score2 = calculatePathScore(path2)
            return score1 < score2
        }
    }
    
    // è¨ˆç®—è·¯å¾‘å¯é æ€§ï¼ˆç”¨æ–¼ç·Šæ€¥è¨Šæ¯ï¼‰
    private func calculatePathReliability(_ path: [String]) -> Float {
        guard path.count > 1 else { return 0.0 }
        
        var totalReliability: Float = 1.0
        
        for nodeID in path {
            if let metrics = routeCache.getMetrics(for: nodeID) {
                // åªè€ƒæ…®æ˜¯å¦å¯é”å’ŒåŸºæœ¬å“è³ª
                if metrics.isReachable && metrics.routeScore > 0.3 {
                    totalReliability *= metrics.routeScore
                } else {
                    return 0.0  // ä»»ä½•ä¸€å€‹ç¯€é»ä¸å¯é ï¼Œæ•´æ¢è·¯å¾‘å°±ä¸å¯é 
                }
            } else {
                totalReliability *= 0.5  // æœªçŸ¥ç¯€é»çµ¦äºˆä¿å®ˆè©•åˆ†
            }
        }
        
        return totalReliability
    }
    
    // è¨ˆç®—è·¯å¾‘è©•åˆ†ï¼ˆç”¨æ–¼ä¸€èˆ¬è¨Šæ¯ï¼‰
    private func calculatePathScore(_ path: [String]) -> Float {
        guard path.count > 1 else { return 0.0 }
        
        let reliability = calculatePathReliability(path)
        
        // è·³æ•¸æ‡²ç½°ï¼šæ¯å¢åŠ ä¸€è·³æ¸›å°‘10%è©•åˆ†
        let hopPenalty = pow(0.9, Float(path.count - 2))
        
        return reliability * hopPenalty
    }
    
    // æª¢æŸ¥è·¯å¾‘æ˜¯å¦æœ‰æ•ˆ
    private func isPathValid(_ path: [String]) -> Bool {
        for nodeID in path {
            if failedNodes.contains(nodeID) {
                return false
            }
            
            if let metrics = routeCache.getMetrics(for: nodeID), !metrics.isReachable {
                return false
            }
        }
        return true
    }
    
    // æ¨™è¨˜æ•…éšœç¯€é»
    func markNodeAsFailed(_ nodeID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        failedNodes.insert(nodeID)
        print("ğŸš« Marked node as failed: \(nodeID)")
    }
    
    // æ¢å¾©ç¯€é»
    func markNodeAsRecovered(_ nodeID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        failedNodes.remove(nodeID)
        print("âœ… Marked node as recovered: \(nodeID)")
    }
    
    // æ›´æ–°ç¯€é»æŒ‡æ¨™
    func updateNodeMetrics(_ metrics: SimpleRouteMetrics) {
        routeCache.updateMetrics(metrics)
        
        // å¦‚æœç¯€é»æ¢å¾©ï¼Œå¾æ•…éšœæ¸…å–®ç§»é™¤
        if metrics.isReachable && failedNodes.contains(metrics.peerID) {
            markNodeAsRecovered(metrics.peerID)
        }
    }
    
    // ç²å–ç¯€é»æŒ‡æ¨™
    func getNodeMetrics(for peerID: String) -> SimpleRouteMetrics? {
        return routeCache.getMetrics(for: peerID)
    }
    
    // ç²å–æ‰€æœ‰ç¯€é»æŒ‡æ¨™
    func getAllNodeMetrics() -> [String: SimpleRouteMetrics] {
        return routeCache.getAllMetrics()
    }
    
    // æ¸…ç†éæœŸè³‡æ–™
    func cleanup() {
        routeCache.clearStaleData()
        
        lock.lock()
        defer { lock.unlock() }
        
        // æ¸…ç†é•·æœŸæ•…éšœçš„ç¯€é»ï¼ˆè¶…é5åˆ†é˜ï¼‰
        let staleFailures = failedNodes.filter { nodeID in
            if let metrics = routeCache.getMetrics(for: nodeID) {
                return Date().timeIntervalSince(metrics.lastHeartbeat) > 300
            }
            return true
        }
        
        for nodeID in staleFailures {
            failedNodes.remove(nodeID)
        }
    }
}

// MARK: - Extended Mesh Message Structure
// æ“´å±• MeshMessage ä»¥æ”¯æ´è·¯ç”±åŠŸèƒ½
struct ExtendedMeshMessage: Codable {
    let id: String
    let type: ExtendedMeshMessageType
    let sourceID: String
    let targetID: String? // nil for broadcast
    let data: Data
    let timestamp: Date
    let ttl: Int // Time To Live
    let hopCount: Int
    let routePath: [String] // è¨˜éŒ„è·¯ç”±è·¯å¾‘
    
    init(type: ExtendedMeshMessageType, sourceID: String, targetID: String? = nil, data: Data, ttl: Int? = nil) {
        self.id = UUID().uuidString
        self.type = type
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = Date()
        // ç·Šæ€¥è¨Šæ¯æœ‰æ›´é•·çš„TTL
        self.ttl = ttl ?? (type.isEmergency ? 20 : 10)
        self.hopCount = 0
        self.routePath = [sourceID]
    }
    
    // ç§æœ‰åˆå§‹åŒ–å™¨ç”¨æ–¼è½‰ç™¼
    private init(type: ExtendedMeshMessageType, sourceID: String, targetID: String?, data: Data, 
                timestamp: Date, ttl: Int, hopCount: Int, routePath: [String]) {
        self.id = UUID().uuidString
        self.type = type
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = timestamp
        self.ttl = ttl
        self.hopCount = hopCount
        self.routePath = routePath
    }
    
    // å‰µå»ºè½‰ç™¼å‰¯æœ¬
    func forwarded(through peerID: String) -> ExtendedMeshMessage {
        return ExtendedMeshMessage(
            type: self.type,
            sourceID: self.sourceID,
            targetID: self.targetID,
            data: self.data,
            timestamp: self.timestamp,
            ttl: self.ttl - 1,
            hopCount: self.hopCount + 1,
            routePath: self.routePath + [peerID]
        )
    }
    
    var isExpired: Bool {
        let maxAge: TimeInterval = type.isEmergency ? 600 : 300  // ç·Šæ€¥è¨Šæ¯10åˆ†é˜ï¼Œä¸€èˆ¬5åˆ†é˜
        return ttl <= 0 || Date().timeIntervalSince(timestamp) > maxAge
    }
    
    private init(type: MeshMessageType, sourceID: String, targetID: String? = nil, 
                 data: Data, timestamp: Date, ttl: Int, hopCount: Int, routePath: [String]) {
        self.id = UUID().uuidString
        self.type = ExtendedMeshMessageType(rawValue: type.stringValue) ?? .system
        self.sourceID = sourceID
        self.targetID = targetID
        self.data = data
        self.timestamp = timestamp
        self.ttl = ttl
        self.hopCount = hopCount
        self.routePath = routePath
    }
}

// MARK: - Network Topology (ç°¡åŒ–ç‰ˆ)
class LocalNetworkTopology {
    private var connections: [String: Set<String>] = [:]
    private let lock = NSLock()
    
    func addConnection(from: String, to: String) {
        lock.lock()
        defer { lock.unlock() }
        
        connections[from, default: Set()].insert(to)
        connections[to, default: Set()].insert(from)
    }
    
    func removeConnection(from: String, to: String) {
        lock.lock()
        defer { lock.unlock() }
        
        connections[from]?.remove(to)
        connections[to]?.remove(from)
        
        if connections[from]?.isEmpty == true {
            connections.removeValue(forKey: from)
        }
        if connections[to]?.isEmpty == true {
            connections.removeValue(forKey: to)
        }
    }
    
    func removePeer(_ peerID: String) {
        lock.lock()
        defer { lock.unlock() }
        
        if let connectedPeers = connections[peerID] {
            for peer in connectedPeers {
                connections[peer]?.remove(peerID)
                if connections[peer]?.isEmpty == true {
                    connections.removeValue(forKey: peer)
                }
            }
        }
        connections.removeValue(forKey: peerID)
    }
    
    func getConnections() -> [String: Set<String>] {
        lock.lock()
        defer { lock.unlock() }
        return connections
    }
    
    // ä½¿ç”¨BFSå°‹æ‰¾è·¯å¾‘ï¼ˆç°¡å–®å¯é ï¼‰
    func findRoute(from source: String, to target: String, excluding excludeNodes: Set<String> = []) -> [String]? {
        lock.lock()
        defer { lock.unlock() }
        
        guard source != target else { return [source] }
        guard !excludeNodes.contains(source) && !excludeNodes.contains(target) else { return nil }
        
        // BFSæœå°‹
        var queue: [(String, [String])] = [(source, [source])]
        var visited: Set<String> = [source]
        
        while !queue.isEmpty {
            let (current, path) = queue.removeFirst()
            
            if let neighbors = connections[current] {
                for neighbor in neighbors {
                    if neighbor == target {
                        return path + [neighbor]
                    }
                    
                    if !visited.contains(neighbor) && !excludeNodes.contains(neighbor) {
                        visited.insert(neighbor)
                        queue.append((neighbor, path + [neighbor]))
                    }
                }
            }
        }
        
        return nil // ç„¡è·¯å¾‘
    }
}

// MARK: - Message Queue (ç·Šæ€¥è¨Šæ¯å„ªå…ˆ)
class MessageQueue {
    private var emergencyQueue: [MeshMessage] = []  // ç·Šæ€¥è¨Šæ¯éšŠåˆ—
    private var normalQueue: [MeshMessage] = []     // ä¸€èˆ¬è¨Šæ¯éšŠåˆ—
    private let lock = NSLock()
    private let maxSize = 500  // æ¸›å°‘è¨˜æ†¶é«”ä½¿ç”¨
    
    // ç²å–è¨Šæ¯å„ªå…ˆç´š
    private func getMessagePriority(for type: MeshMessageType) -> MessagePriority {
        switch type {
        case .emergency:
            return .emergency
        case .system, .keyExchange, .keyExchangeResponse:
            return .high
        default:
            return .normal
        }
    }
    
    func enqueue(_ message: MeshMessage) {
        lock.lock()
        defer { lock.unlock() }
        
        if message.type.isEmergency {
            emergencyQueue.append(message)
            
            // é™åˆ¶ç·Šæ€¥éšŠåˆ—å¤§å°
            if emergencyQueue.count > maxSize / 4 {
                emergencyQueue.removeFirst()
            }
        } else {
            // ä¸€èˆ¬è¨Šæ¯æŒ‰å„ªå…ˆç´šæ’å…¥
            let messagePriority = getMessagePriority(for: message.type)
            let insertIndex = normalQueue.firstIndex { 
                let otherPriority = getMessagePriority(for: $0.type)
                return otherPriority.rawValue < messagePriority.rawValue 
            } ?? normalQueue.count
            normalQueue.insert(message, at: insertIndex)
            
            // é™åˆ¶ä¸€èˆ¬éšŠåˆ—å¤§å°
            if normalQueue.count > maxSize {
                normalQueue.removeLast()
            }
        }
    }
    
    func dequeue() -> MeshMessage? {
        lock.lock()
        defer { lock.unlock() }
        
        // æ¸…ç†éæœŸè¨Šæ¯
        emergencyQueue.removeAll { $0.isExpired }
        normalQueue.removeAll { $0.isExpired }
        
        // ç·Šæ€¥è¨Šæ¯å„ªå…ˆ
        if !emergencyQueue.isEmpty {
            return emergencyQueue.removeFirst()
        }
        
        return normalQueue.isEmpty ? nil : normalQueue.removeFirst()
    }
    
    func clear() {
        lock.lock()
        defer { lock.unlock() }
        emergencyQueue.removeAll()
        normalQueue.removeAll()
    }
    
    var count: Int {
        lock.lock()
        defer { lock.unlock() }
        return emergencyQueue.count + normalQueue.count
    }
    
    var emergencyCount: Int {
        lock.lock()
        defer { lock.unlock() }
        return emergencyQueue.count
    }
}

// MARK: - Network Statistics
struct NetworkStats {
    var messagesSent: Int = 0
    var messagesReceived: Int = 0
    var messagesForwarded: Int = 0
    var emergencyMessagesSent: Int = 0
    var emergencyMessagesReceived: Int = 0
    var connectedPeersCount: Int = 0
    var averageRouteLength: Double = 0.0
    var networkReliability: Float = 1.0
    var blockedConnections: Int = 0
    
    // æ´ªæ°´é˜²è­·çµ±è¨ˆ
    var blockedMessages: Int = 0
    var lastBlockedPeer: String = ""
    var lastBlockedTime: Date = Date()
    var connectionRateProtectionEnabled: Bool = true
}

// MARK: - Connection Rate Manager Protocol
protocol ConnectionRateManagerProtocol {
    func shouldBlock(_ message: MeshMessage, from peerID: String) -> Bool
}

// NetworkServiceProtocol å®šç¾©å·²ç§»è‡³ ServiceProtocols.swift

// SecurityServiceProtocol å®šç¾©å·²ç§»è‡³ ServiceProtocols.swift

// MARK: - Simple Connection Rate Manager
class SimpleConnectionRateManager: ConnectionRateManagerProtocol {
    private var messageHistory: [String: [Date]] = [:]
    private let lock = NSLock()
    private let maxMessagesPerMinute = 60
    private let windowSize: TimeInterval = 60.0
    
    func shouldBlock(_ message: MeshMessage, from peerID: String) -> Bool {
        // ç·Šæ€¥è¨Šæ¯æ°¸ä¸é˜»æ“‹
        guard !message.type.isEmergency else { return false }
        
        lock.lock()
        defer { lock.unlock() }
        
        let now = Date()
        let cutoffTime = now.addingTimeInterval(-windowSize)
        
        // æ¸…ç†éæœŸè¨˜éŒ„
        messageHistory[peerID] = messageHistory[peerID]?.filter { $0 > cutoffTime } ?? []
        
        // æª¢æŸ¥æ˜¯å¦è¶…éé™åˆ¶
        let recentCount = messageHistory[peerID]?.count ?? 0
        if recentCount >= maxMessagesPerMinute {
            print("ğŸš« Blocking excessive connections from \(peerID): \(recentCount) messages in last minute")
            return true
        }
        
        // è¨˜éŒ„æ­¤æ¬¡è¨Šæ¯
        messageHistory[peerID, default: []].append(now)
        return false
    }
}

// MARK: - Mesh Manager (æ™ºèƒ½è·¯ç”±æ•´åˆç‰ˆ)
@MainActor
class MeshManager: MeshNetworkProtocol, MeshManagerProtocol, ObservableObject {
    // MARK: - Dependencies
    private let networkService: NetworkServiceProtocol
    private let securityService: SecurityService
    private let connectionRateManager: ConnectionRateManagerProtocol
    private let advancedConnectionRateManager: ConnectionRateManager?
    private let trustScoreManager: TrustScoreManager
    private let networkStateCoordinator: NetworkStateCoordinator = NetworkStateCoordinator.shared
    
    // MARK: - Core Components
    private var topology = LocalNetworkTopology()
    private let messageQueue = MessageQueue()
    private let intelligentRouter = SimpleIntelligentRouter()
    private let emergencyRateLimiter = EmergencyRateLimiter()
    
    // ç·šç¨‹å®‰å…¨çš„ processedMessages ç®¡ç†
    private let processedMessagesQueue = DispatchQueue(label: "com.signalair.meshmanager.messages", attributes: .concurrent)
    private var _processedMessages: Set<String> = []
    private let processedMessagesLimit = 1000  // æ¸›å°‘è¨˜æ†¶é«”ä½¿ç”¨å¾5000é™åˆ°1000
    
    // ã€NEWã€‘éŠæˆ²æ¶ˆæ¯æ¥æ”¶å›èª¿
    var onGameMessageReceived: ((MeshMessage) -> Void)?
    
    // ç·šç¨‹å®‰å…¨çš„ processedMessages å­˜å–
    private var processedMessages: Set<String> {
        get {
            return processedMessagesQueue.sync { _processedMessages }
        }
        set {
            processedMessagesQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._processedMessages = newValue
                }
            }
        }
    }
    
    // MARK: - Timers
    private var heartbeatTimer: Timer?
    private var queueProcessingTimer: Timer?
    private var metricsCleanupTimer: Timer?
    
    // MARK: - Configuration (ç½é›£é€šä¿¡å„ªåŒ–)
    private let heartbeatInterval: TimeInterval = 120.0     // 2åˆ†é˜å¿ƒè·³ (å¤§è¦æ¨¡meshå„ªåŒ–)  
    private let queueProcessingInterval: TimeInterval = 0.2  // 200msè™•ç†é–“éš” (æ¸›å°‘CPUè² è¼‰)
    private let metricsCleanupInterval: TimeInterval = 300.0 // 5åˆ†é˜æ¸…ç†ä¸€æ¬¡ (æ¸›å°‘é »ç¹æ“ä½œ)
    
    // MARK: - Send Failure Tracking (ç·šç¨‹å®‰å…¨)
    private let failureTrackingQueue = DispatchQueue(label: "com.signalair.meshmanager.failure", attributes: .concurrent)
    private var _sendFailureCounts: [String: Int] = [:]
    private var _lastFailureTime: [String: Date] = [:]
    private let maxFailureCount = 3  // æœ€å¤šå…è¨±3æ¬¡å¤±æ•—
    private let failureResetInterval: TimeInterval = 300.0  // 5åˆ†é˜å¾Œé‡ç½®å¤±æ•—è¨ˆæ•¸
    
    // ç·šç¨‹å®‰å…¨çš„å¤±æ•—è¨ˆæ•¸è¨ªå•
    private var sendFailureCounts: [String: Int] {
        get { 
            return failureTrackingQueue.sync { _sendFailureCounts } 
        }
        set { 
            failureTrackingQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._sendFailureCounts = newValue
                }
            }
        }
    }
    
    private var lastFailureTime: [String: Date] {
        get { 
            return failureTrackingQueue.sync { _lastFailureTime } 
        }
        set { 
            failureTrackingQueue.async(flags: .barrier) { [weak self] in
                Task { @MainActor in
                    self?._lastFailureTime = newValue
                }
            }
        }
    }
    
    // MARK: - Published State
    @Published var connectedPeers: [String] = []
    @Published var networkStats: NetworkStats = NetworkStats()
    @Published var isActive: Bool = false
    @Published var routingMetrics: [String: SimpleRouteMetrics] = [:]
    
    // MARK: - Callbacks
    var onDataReceived: ((Data, MeshMessageType, String) -> Void)?
    var onNetworkTopologyChanged: (([String: Set<String>]) -> Void)?
    var onEmergencyMessage: ((Data, MeshMessageType, String) -> Void)?
    
    // MARK: - Protocol Callbacks (ç¬¦åˆ MeshManagerProtocol)
    var onMessageReceived: ((MeshMessage) -> Void)?
    var onPeerConnected: ((String) -> Void)?
    var onPeerDisconnected: ((String) -> Void)?
    
    // MARK: - Initialization
    init(networkService: NetworkServiceProtocol, 
         securityService: SecurityService,
         trustScoreManager: TrustScoreManager,
         connectionRateManager: ConnectionRateManagerProtocol? = nil,
         advancedConnectionRateManager: ConnectionRateManager? = nil) {
        self.networkService = networkService
        self.securityService = securityService
        self.trustScoreManager = trustScoreManager
        
        // å„ªå…ˆä½¿ç”¨é«˜ç´šæ´ªæ°´é˜²è­·ï¼Œå›é€€åˆ°ç°¡å–®ç‰ˆæœ¬
        if let advancedProtection = advancedConnectionRateManager {
            self.connectionRateManager = advancedProtection
            self.advancedConnectionRateManager = advancedProtection
            print("ğŸ›¡ï¸ Using advanced connection rate manager system")
        } else {
            self.connectionRateManager = connectionRateManager ?? SimpleConnectionRateManager()
            self.advancedConnectionRateManager = nil
            print("ğŸ›¡ï¸ Using simple connection rate manager system")
        }
        
        setupNetworkCallbacks()
        startServices()
        
        print("ğŸ•¸ï¸ MeshManager initialized with intelligent routing")
    }
    
    deinit {
        // ç·šç¨‹å®‰å…¨çš„ Timer æ¸…ç†
        DispatchQueue.main.async { [weak self] in
            self?.heartbeatTimer?.invalidate()
            self?.queueProcessingTimer?.invalidate()
            self?.metricsCleanupTimer?.invalidate()
        }
        
        // åœæ­¢ç¶²è·¯æœå‹™
        Task { @MainActor [weak self] in
            self?.stopMeshNetwork()
            self?.clearProcessedMessages()
        }
        
        print("ğŸ§¹ MeshManager: æ‰€æœ‰è³‡æºå·²æ¸…ç†")
    }
    
    // MARK: - Security Integration
    
    /// é€šçŸ¥å®‰å…¨ç›£æ§ç³»çµ±
    private func notifySecurityHealthMonitor(event: SecurityEventType, peerID: String, details: String) async {
        // ä½¿ç”¨ NotificationCenter é€šçŸ¥å®‰å…¨ç›£æ§ç³»çµ±
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: NSNotification.Name("SecurityEvent"),
                object: nil,
                userInfo: [
                    "event": event.rawValue,
                    "peerID": peerID,
                    "details": details,
                    "timestamp": Date(),
                    "source": "MeshManager"
                ]
            )
        }
        
        print("âš ï¸ Security event reported: \(event.rawValue) from \(peerID)")
    }
    
    /// æª¢æŸ¥ç·Šæ€¥è¨Šæ¯æ˜¯å¦æ‡‰è©²ç¹éé€£ç·šé€Ÿç‡ä¿è­·
    /// ğŸ”§ FIX: æ•´åˆç·Šæ€¥è¨Šæ¯å°ˆç”¨é€Ÿç‡é™åˆ¶å™¨
    private func shouldBypassConnectionRateProtection(message: MeshMessage, from peerID: String) -> Bool {
        // ğŸš¨ ç·Šæ€¥è¨Šæ¯ç¾åœ¨æœ‰å°ˆé–€çš„é€Ÿç‡é™åˆ¶å™¨
        if message.type.isEmergency {
            // ç·Šæ€¥è¨Šæ¯ä»ç„¶éœ€è¦é€šéå°ˆé–€çš„ç·Šæ€¥é€Ÿç‡æª¢æŸ¥
            let allowed = emergencyRateLimiter.shouldAllowEmergencyMessage(from: peerID)
            if !allowed {
                print("ğŸš« ç·Šæ€¥è¨Šæ¯è¢«ç·Šæ€¥é€Ÿç‡é™åˆ¶å™¨é˜»æ­¢: \(peerID)")
                // è¨˜éŒ„çµ±è¨ˆ
                networkStats.blockedMessages += 1
                networkStats.lastBlockedPeer = peerID
                networkStats.lastBlockedTime = Date()
            }
            return allowed
        }
        
        // ç³»çµ±é—œéµè¨Šæ¯ç¹éé€£ç·šé€Ÿç‡ä¿è­·
        if message.type == .system || message.type == .keyExchange {
            return true
        }
        
        return false
    }
    
    /// æª¢æŸ¥æ˜¯å¦ç‚ºéŠæˆ²é€šè¨Šï¼ˆç™½åå–®æ©Ÿåˆ¶ï¼‰
    private func isGameCommunication(message: MeshMessage) -> Bool {
        // éŠæˆ²ç›¸é—œè¨Šæ¯é¡å‹ç™½åå–®
        let gameMessageTypes: [MeshMessageType] = [
            .game,           // è³“æœéŠæˆ²æ¶ˆæ¯
            .routingUpdate,  // è·¯ç”±æ›´æ–°
            .signal         // ä¿¡è™Ÿæ¶ˆæ¯
        ]
        
        // æª¢æŸ¥æ¶ˆæ¯é¡å‹
        if gameMessageTypes.contains(message.type) {
            return true
        }
        
        // æª¢æŸ¥æ¶ˆæ¯å…§å®¹ä¸­çš„éŠæˆ²é—œéµå­—
        if let messageContent = String(data: message.data, encoding: .utf8) {
            let gameKeywords = [
                "room_sync", "game_start", "number_drawn", "game_restart",
                "player_join", "player_leave", "bingo_card", "reconnect_request",
                "weekly_leaderboard", "host_promotion", "game_state"
            ]
            
            return gameKeywords.contains { messageContent.contains($0) }
        }
        
        return false
    }
    
    // MARK: - MeshNetworkProtocol Implementation
    
    func startMeshNetwork() {
        if !isActive {
            // 1. å ±å‘Šç¶²æ ¼å±¤æ­£åœ¨é€£æ¥
            networkStateCoordinator.reportMeshLayerState(.connecting)
            
            startServices()
            
            // 2. å ±å‘Šç¶²æ ¼å±¤å·²é€£æ¥
            networkStateCoordinator.reportMeshLayerState(.connected, peerCount: getConnectedPeers().count)
            
            print("ğŸ•¸ï¸ MeshManager: Mesh ç¶²è·¯å·²å•Ÿå‹•")
        }
    }
    
    func stopMeshNetwork() {
        if isActive {
            // 1. å ±å‘Šç¶²æ ¼å±¤æ–·ç·š
            networkStateCoordinator.reportMeshLayerState(.disconnected)
            
            stopServices()
            print("ğŸ›‘ MeshManager: Mesh ç¶²è·¯å·²åœæ­¢")
        }
    }
    
    func broadcastMessage(_ data: Data, messageType: MeshMessageType) {
        // ğŸš¨ ç½é›£é€šä¿¡å„ªåŒ–ï¼šé˜²æ­¢æ¶ˆæ¯é¢¨æš´çš„å»£æ’­æ©Ÿåˆ¶
        let connectedPeers = networkService.connectedPeers
        
        // 2. æª¢æŸ¥æ˜¯å¦æœ‰é€£æ¥çš„è¨­å‚™
        guard !connectedPeers.isEmpty else {
            print("ğŸ“± ç„¡é€£æ¥è¨­å‚™ï¼Œè·³éå»£æ’­ \(messageType.rawValue)")
            return
        }
        
        // 3. å°ç·Šæ€¥æ¶ˆæ¯çµ¦äºˆå„ªå…ˆè™•ç†
        let isEmergency = messageType.isEmergency
        if isEmergency {
            print("ğŸš¨ ç·Šæ€¥æ¶ˆæ¯å»£æ’­: \(messageType.rawValue)")
        }
        
        // 4. å‰µå»ºå„ªåŒ–çš„MeshMessage
        let message = MeshMessage(
            id: UUID().uuidString,
            type: messageType,
            data: data
        )
        
        // 5. äºŒé€²åˆ¶ç·¨ç¢¼ï¼ˆç½é›£å ´æ™¯å„ªåŒ–ï¼‰
        do {
            let binaryData = try BinaryMessageEncoder.encode(message)
            let dataSize = binaryData.count
            
            // 6. æª¢æŸ¥æ•¸æ“šå¤§å°ï¼ˆé˜²æ­¢å¤§æ•¸æ“šåŒ…é˜»å¡ï¼‰
            if dataSize > 1024 && !isEmergency {
                print("âš ï¸ éç·Šæ€¥æ¶ˆæ¯éå¤§ (\(dataSize) bytes)ï¼Œè€ƒæ…®åˆ†ç‰‡")
            }
            
            print("ğŸ“¦ å»£æ’­ \(messageType.rawValue): \(dataSize) bytes â†’ \(connectedPeers.count) è¨­å‚™")
            
            // 7. ç•°æ­¥ä¸¦ç™¼ç™¼é€ï¼ˆæé«˜æ•ˆç‡ï¼‰
            Task {
                await withTaskGroup(of: Void.self) { group in
                    for peer in connectedPeers {
                        group.addTask {
                            do {
                                try await self.networkService.send(binaryData, to: [peer])
                            } catch {
                                print("âŒ å»£æ’­åˆ° \(peer.displayName) å¤±æ•—: \(error)")
                                // è¨˜éŒ„å¤±æ•—ä½†ä¸é˜»å¡å…¶ä»–ç™¼é€
                            }
                        }
                    }
                }
            }
            
        } catch {
            print("âŒ å»£æ’­ç·¨ç¢¼å¤±æ•—: \(error)")
        }
    }
    
    func sendDirectMessage(_ data: Data, to peerID: String, messageType: MeshMessageType) {
        let message = MeshMessage(
            type: messageType,
            sourceID: networkService.myPeerID.displayName,
            targetID: peerID,
            data: data
        )
        
        processOutgoingMessage(message)
        
        // æ›´æ–°çµ±è¨ˆ
        updateStats(for: message, isSent: true)
        
        print("ğŸ“¤ Sending \(messageType.rawValue) message to \(peerID)")
    }
    
    func getConnectedPeers() -> [String] {
        // ğŸ”§ ä¿®å¾©ï¼šè¿”å›å¯¦éš›é€£æ¥çš„è¨­å‚™IDï¼Œä¸æ˜¯æ‹“æ’²åœ–ä¸­çš„æ‰€æœ‰ç¯€é»
        return networkService.connectedPeers.map { $0.displayName }
    }
    
    func getNetworkTopology() -> [String: Set<String>] {
        return topology.getConnections()
    }
    
    // MARK: - Emergency Message API
    
    func sendEmergencyMessage(_ data: Data, type: MeshMessageType) {
        guard type.isEmergency else {
            print("âŒ Message type \(type.rawValue) is not emergency")
            return
        }
        
        // æª¢æŸ¥è‡ªå·±æ˜¯å¦å¯ä»¥ç™¼é€ç·Šæ€¥è¨Šæ¯
        let myPeerID = networkService.myPeerID.displayName
        guard emergencyRateLimiter.shouldAllowEmergencyMessage(from: myPeerID) else {
            print("ğŸš« Emergency message blocked by rate limiter for self: \(myPeerID)")
            return
        }
        
        broadcastMessage(data, messageType: type)
        print("ğŸš¨ Emergency \(type.rawValue) message sent")
    }
    
    
    // MARK: - Advanced Connection Rate Manager API
    
    /// ç²å–é«˜ç´šé€£ç·šé€Ÿç‡ç®¡ç†çµ±è¨ˆ
    func getAdvancedConnectionRateStats() -> ConnectionRateStats? {
        return advancedConnectionRateManager?.getStats()
    }
    
    /// æ‰‹å‹•å°ç¦ç¯€é»
    func banPeer(_ peerID: String, duration: TimeInterval? = nil) {
        advancedConnectionRateManager?.banPeer(peerID, duration: duration)
        print("ğŸš« Manually banned peer: \(peerID)")
    }
    
    /// è§£å°ç¯€é»
    func unbanPeer(_ peerID: String) {
        advancedConnectionRateManager?.unbanPeer(peerID)
        print("âœ… Manually unbanned peer: \(peerID)")
    }
    
    /// ç²å–å·²å°ç¦çš„ç¯€é»
    func getBannedPeers() -> [String: Date] {
        return advancedConnectionRateManager?.getBannedPeers() ?? [:]
    }
    
    /// ç²å–ç¯€é»å°ç¦æ­·å²
    func getBanHistory(for peerID: String) -> Int {
        return advancedConnectionRateManager?.getBanHistory(for: peerID) ?? 0
    }
    
    /// ç²å–å°ç¦çµ±è¨ˆ
    func getBanStatistics() -> BanStatistics? {
        return advancedConnectionRateManager?.getBanStatistics()
    }
    
    /// å•Ÿç”¨/åœç”¨é€£ç·šé€Ÿç‡ä¿è­·
    func setConnectionRateProtectionActive(_ active: Bool) {
        advancedConnectionRateManager?.setActive(active)
        print("ğŸ›¡ï¸ Connection rate protection \(active ? "enabled" : "disabled")")
    }
    
    /// æ¸…é™¤æ‰€æœ‰å°ç¦
    func clearAllBans() {
        advancedConnectionRateManager?.clearAllBans()
        print("ğŸ§¹ All bans cleared")
    }
    
    /// é‡ç½®é€£ç·šé€Ÿç‡ç®¡ç†çµ±è¨ˆ
    func resetConnectionRateStats() {
        advancedConnectionRateManager?.resetStats()
        print("ğŸ“Š Connection rate manager stats reset")
    }
    
    // MARK: - Route Management
    
    func updateNodeMetrics(peerID: String, signalStrength: Float, packetLoss: Float) {
        let metrics = SimpleRouteMetrics(
            peerID: peerID,
            signalStrength: signalStrength,
            packetLoss: packetLoss,
            isReachable: true,
            lastHeartbeat: Date()
        )
        
        intelligentRouter.updateNodeMetrics(metrics)
        
        DispatchQueue.main.async {
            self.routingMetrics[peerID] = metrics
        }
    }
    
    func markNodeAsFailed(_ peerID: String) {
        intelligentRouter.markNodeAsFailed(peerID)
        
        // å¾æ‹“æ’²ä¸­ç§»é™¤
        topology.removePeer(peerID)
        updateConnectedPeers()
        
        print("ğŸš« Node \(peerID) marked as failed")
    }
    
    /// è¨˜éŒ„ç™¼é€å¤±æ•—ï¼Œåªæœ‰åœ¨å¤šæ¬¡å¤±æ•—å¾Œæ‰æ¨™è¨˜ç¯€é»ç‚ºå¤±æ•—
    private func recordSendFailure(for peerID: String) {
        let now = Date()
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®å¤±æ•—è¨ˆæ•¸ï¼ˆè¶…éé‡ç½®é–“éš”ï¼‰
        if let lastFailure = lastFailureTime[peerID],
           now.timeIntervalSince(lastFailure) > failureResetInterval {
            sendFailureCounts[peerID] = 0
        }
        
        // å¢åŠ å¤±æ•—è¨ˆæ•¸
        sendFailureCounts[peerID, default: 0] += 1
        lastFailureTime[peerID] = now
        
        let failureCount = sendFailureCounts[peerID, default: 0]
        print("âš ï¸ Send failure for \(peerID): \(failureCount)/\(maxFailureCount)")
        
        // åªæœ‰åœ¨é”åˆ°æœ€å¤§å¤±æ•—æ¬¡æ•¸æ™‚æ‰æ¨™è¨˜ç‚ºå¤±æ•—
        if failureCount >= maxFailureCount {
            print("ğŸš« Node \(peerID) exceeded max failure count, marking as failed")
            markNodeAsFailed(peerID)
            
            // æ¸…ç†å¤±æ•—è¨˜éŒ„
            sendFailureCounts.removeValue(forKey: peerID)
            lastFailureTime.removeValue(forKey: peerID)
        }
    }
    
    /// æ¸…ç†æˆåŠŸç™¼é€å¾Œçš„å¤±æ•—è¨˜éŒ„
    private func clearSendFailure(for peerID: String) {
        if sendFailureCounts[peerID] != nil {
            sendFailureCounts.removeValue(forKey: peerID)
            lastFailureTime.removeValue(forKey: peerID)
            print("âœ… Cleared failure record for \(peerID)")
        }
    }
    
    // MARK: - Private Methods
    
    /// åˆ¤æ–·æ¶ˆæ¯æ˜¯å¦éœ€è¦åŠ å¯†ï¼ˆé¸æ“‡æ€§åŠ å¯†ç­–ç•¥ï¼‰
    private func shouldEncryptMessage(_ message: MeshMessage) -> Bool {
        // éŠæˆ²æ¶ˆæ¯éœ€è¦æ ¹æ“šå…·é«”é¡å‹åˆ¤æ–·
        if message.type == .game {
            return shouldEncryptGameMessage(message.data)
        }
        
        // å…¶ä»–æ¶ˆæ¯é¡å‹çš„åŠ å¯†ç­–ç•¥
        switch message.type {
        case .chat:
            return true  // èŠå¤©æ¶ˆæ¯å§‹çµ‚åŠ å¯†ï¼ˆéš±ç§ä¿è­·ï¼‰
        case .signal:
            return false // ä¿¡è™Ÿæ¶ˆæ¯é€šå¸¸æ˜¯å…¬é–‹è³‡è¨Š
        case .emergency:
            return false // ç·Šæ€¥æ¶ˆæ¯éœ€è¦å¿«é€Ÿå‚³æ’­ï¼Œä¸åŠ å¯†
        case .system:
            return true  // ç³»çµ±æ¶ˆæ¯å¯èƒ½åŒ…å«æ•æ„Ÿè³‡è¨Š
        case .keyExchange, .keyExchangeResponse:
            return false // å¯†é‘°äº¤æ›æœ¬èº«ä¸éœ€è¦åŠ å¯†
        case .topology, .routingUpdate:
            return false // ç¶²çµ¡æ‹“æ’²æ˜¯å…¬é–‹è³‡è¨Š
        case .heartbeat:
            return false // å¿ƒè·³æ¶ˆæ¯ç„¡æ•æ„Ÿè³‡è¨Š
        case .game:
            return false // éŠæˆ²æ¶ˆæ¯å·²åœ¨ä¸Šé¢è™•ç†ï¼Œé€™è£¡ä¸æ‡‰è©²åˆ°é”
        }
    }
    
    /// åˆ¤æ–·éŠæˆ²æ¶ˆæ¯æ˜¯å¦éœ€è¦åŠ å¯†
    private func shouldEncryptGameMessage(_ gameData: Data) -> Bool {
        // è§£æéŠæˆ²æ¶ˆæ¯é¡å‹ï¼ˆç¬¬ä¸€å€‹å­—ç¯€ï¼‰
        guard !gameData.isEmpty else { return false }
        
        let gameMessageType = gameData[0]
        
        // åŸºæ–¼æ‚¨çš„åˆ†æï¼Œä»¥ä¸‹æ˜¯ä¸éœ€è¦åŠ å¯†çš„å…¬é–‹è³‡è¨Š
        switch gameMessageType {
        // ğŸ¯ éŠæˆ²æ ¸å¿ƒå…¬é–‹è³‡è¨Š - ä¸åŠ å¯†
        case 0x06: // numberDrawn - æŠ½å–è™Ÿç¢¼ï¼ˆæ‰€æœ‰äººéƒ½éœ€è¦çœ‹åˆ°ï¼‰
            return false
        case 0x40: // turnChange - è¼ªæµè®Šæ›´ï¼ˆå…¬å¹³æ€§è¦æ±‚ï¼‰
            return false
        case 0x09: // gameStart - éŠæˆ²é–‹å§‹ï¼ˆç‹€æ…‹åŒæ­¥ï¼‰
            return false
        case 0x0A: // gameEnd - éŠæˆ²çµæŸï¼ˆç‹€æ…‹åŒæ­¥ï¼‰
            return false
        case 0x0F: // bingoWon - è³“æœå‹åˆ©ï¼ˆå…¬é–‹æ…¶ç¥ï¼‰
            return false
        case 0x0C: // emote - è¡¨æƒ…ï¼ˆç¤¾äº¤äº’å‹•ï¼‰
            return false
        case 0x0B: // heartbeat - å¿ƒè·³ï¼ˆé€£ç·šä¿¡è™Ÿï¼‰
            return false
            
        // ğŸ” éš±ç§æ•æ„Ÿè³‡è¨Š - éœ€è¦åŠ å¯†
        case 0x01: // playerJoined - ç©å®¶åŠ å…¥ï¼ˆåŒ…å«è¨­å‚™IDï¼‰
            return true
        case 0x02: // playerLeft - ç©å®¶é›¢é–‹ï¼ˆåŒ…å«è¨­å‚™è³‡è¨Šï¼‰
            return true
        case 0x0E: // roomStateUpdate - æˆ¿é–“ç‹€æ…‹ï¼ˆå¯èƒ½åŒ…å«ç©å®¶åˆ—è¡¨ï¼‰
            return true
        case 0x0D: // roomStateRequest - æˆ¿é–“è«‹æ±‚ï¼ˆéš±ç§æŸ¥è©¢ï¼‰
            return true
        case 0x07: // playerProgress - ç©å®¶é€²åº¦ï¼ˆå€‹äººè³‡è¨Šï¼‰
            return true
        case 0x08: // chatMessage - éŠæˆ²å…§èŠå¤©ï¼ˆéš±ç§ä¿è­·ï¼‰
            return true
            
        // ğŸ¤” å…¶ä»–æ¶ˆæ¯é¡å‹é è¨­åŠ å¯†ï¼ˆä¿å®ˆç­–ç•¥ï¼‰
        default:
            return true
        }
    }
    
    /// åˆ¤æ–·æ¥æ”¶åˆ°çš„æ•¸æ“šæ˜¯å¦ç‚ºåŠ å¯†æ¶ˆæ¯
    private func isEncryptedMessage(_ data: Data) -> Bool {
        // ChaCha20 åŠ å¯†æ¶ˆæ¯çš„æ¨™è­˜æ˜¯ç¬¬ä¸€å€‹å­—ç¯€ç‚º 0x01
        guard !data.isEmpty else { return false }
        return data[0] == 0x01
    }
    
    private func convertToMeshMessageType(_ extendedType: ExtendedMeshMessageType) -> MeshMessageType {
        switch extendedType {
        case .emergencyMedical, .emergencyDanger:
            return .emergency
        case .signal:
            return .signal
        case .chat:
            return .chat
        case .game:
            return .game
        case .heartbeat:
            return .heartbeat
        case .routingUpdate:
            return .routingUpdate
        case .keyExchange:
            return .keyExchange
        case .system:
            return .system
        }
    }
    
    private func setupNetworkCallbacks() {
        // ğŸ”§ FIX: ç§»é™¤onDataReceivedå›èª¿è¨­ç½®ï¼Œé¿å…èˆ‡ServiceContainerè¡çª
        // ServiceContainerç¾åœ¨æ˜¯å”¯ä¸€çš„æ•¸æ“šè™•ç†å…¥å£ï¼Œæœƒåˆ†ç™¼æ¶ˆæ¯çµ¦MeshManager
        // networkService.onDataReceived - ä¸å†è¨­ç½®ï¼Œç”±ServiceContainerçµ±ä¸€è™•ç†
        
        networkService.onPeerConnected = { [weak self] peerID in
            self?.handlePeerConnected(peerID)
        }
        
        networkService.onPeerDisconnected = { [weak self] peerID in
            self?.handlePeerDisconnected(peerID)
        }
    }
    
    private func startServices() {
        isActive = true
        
        // å•Ÿå‹•å¿ƒè·³è¨ˆæ™‚å™¨ï¼ˆä¿®å¾©å¾ªç’°å¼•ç”¨ï¼‰
        heartbeatTimer = Timer.scheduledTimer(withTimeInterval: heartbeatInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.sendHeartbeat()
            }
        }
        
        // å•Ÿå‹•è¨Šæ¯ä½‡åˆ—è™•ç†ï¼ˆä¿®å¾©å¾ªç’°å¼•ç”¨ï¼‰
        queueProcessingTimer = Timer.scheduledTimer(withTimeInterval: queueProcessingInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.processMessageQueue()
            }
        }
        
        // å•Ÿå‹•æ¸…ç†è¨ˆæ™‚å™¨ï¼ˆä¿®å¾©å¾ªç’°å¼•ç”¨ï¼‰
        metricsCleanupTimer = Timer.scheduledTimer(withTimeInterval: metricsCleanupInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor in
                self.performCleanup()
            }
        }
        
        print("ğŸš€ MeshManager services started")
    }
    
    private func stopServices() {
        isActive = false
        
        // ç·šç¨‹å®‰å…¨çš„ Timer æ¸…ç†
        DispatchQueue.main.async { [weak self] in
            self?.heartbeatTimer?.invalidate()
            self?.heartbeatTimer = nil
            self?.queueProcessingTimer?.invalidate()
            self?.queueProcessingTimer = nil
            self?.metricsCleanupTimer?.invalidate()
            self?.metricsCleanupTimer = nil
        }
        
        messageQueue.clear()
        
        print("ğŸ›‘ MeshManager services stopped")
    }
    
    private func handleIncomingData(_ data: Data, from peerID: String) async {
        do {
            // æ™ºèƒ½è§£å¯†ï¼šå…ˆå˜—è©¦è§£ææ¶ˆæ¯é¡å‹ï¼Œå†æ±ºå®šæ˜¯å¦è§£å¯†
            let decryptedData: Data
            if isEncryptedMessage(data) {
                let hasKey = await securityService.hasSessionKey(for: peerID)
                if hasKey {
                    decryptedData = try await securityService.decrypt(data, from: peerID)
                    print("ğŸ”“ å·²è§£å¯†è¨Šæ¯ä¾†è‡ª: \(peerID)")
                } else {
                    // åŠ å¯†è¨Šæ¯ä½†ç„¡å¯†é‘°ï¼Œå¯èƒ½æ˜¯éš±ç§è¨Šæ¯å‚³è¼¸å¤±æ•—
                    print("âš ï¸ æ”¶åˆ°åŠ å¯†è¨Šæ¯ä½†ç„¡å¯†é‘°ï¼Œä¾†è‡ª: \(peerID)")
                    decryptedData = data // å˜—è©¦æŒ‰æ˜æ–‡è™•ç†
                }
            } else {
                // æ˜æ–‡è¨Šæ¯ï¼ˆå…¬é–‹è³‡è¨Šï¼‰
                decryptedData = data
                print("ğŸ“¢ æ”¶åˆ°æ˜æ–‡å…¬é–‹è¨Šæ¯ä¾†è‡ª: \(peerID)")
            }
            
            // è§£æè¨Šæ¯ (ä½¿ç”¨äºŒé€²åˆ¶å”è­°æ›¿æ›JSON) - å¢å¼·è¨ºæ–·
            let message: MeshMessage
            do {
                message = try BinaryMessageDecoder.decode(decryptedData)
            } catch {
                // ğŸ” è©³ç´°è¨ºæ–·å¤±æ•—çš„æ•¸æ“š
                let analysis = BinaryMessageDecoder.analyzeFailedData(decryptedData)
                print("âŒ è§£ç¢¼å¤±æ•—è©³ç´°åˆ†æ:")
                print(analysis)
                let hasSessionKey = await securityService.hasSessionKey(for: peerID)
                print("ğŸ” åŠ å¯†ç‹€æ…‹: hasSessionKey = \(hasSessionKey)")
                print("ğŸ” åŸå§‹æ•¸æ“šå¤§å°: \(data.count) bytes")
                print("ğŸ” è§£å¯†å¾Œæ•¸æ“šå¤§å°: \(decryptedData.count) bytes")
                
                // å˜—è©¦ä¸åŒçš„è§£ç¢¼ç­–ç•¥
                if let signalTuple = SignalBinaryCodec.decodeInlineSignalData(decryptedData) {
                    print("âœ… æˆåŠŸè§£ç¢¼ç‚ºä¿¡è™Ÿæ•¸æ“š: é¡å‹=\(signalTuple.type), è¨­å‚™=\(signalTuple.deviceName)")
                    // å°‡ä¿¡è™Ÿæ•¸æ“šè½‰ç™¼åˆ°é©ç•¶çš„è™•ç†å™¨
                    Task {
                        await handleInlineSignalTuple(signalTuple, from: peerID)
                    }
                    return
                }
                
                throw error
            }
            
            // ğŸ›¡ï¸ å¢å¼·é€£ç·šé€Ÿç‡ä¿è­·æª¢æŸ¥ï¼ˆç·Šæ€¥è¨Šæ¯æœ‰å°ˆé–€é™åˆ¶å™¨ï¼‰
            if !shouldBypassConnectionRateProtection(message: message, from: peerID) {
                if connectionRateManager.shouldBlock(message, from: peerID) {
                    print("ğŸš« Connection rate protection: Blocked message from \(peerID) (ID: \(message.id), Type: \(message.type.rawValue))")
                    
                    // è¨˜éŒ„æ”»æ“Šçµ±è¨ˆ
                    networkStats.blockedMessages += 1
                    networkStats.lastBlockedPeer = peerID
                    networkStats.lastBlockedTime = Date()
                    
                    // è¨˜éŒ„åˆ°å®‰å…¨æ—¥èªŒ
                    Task { @MainActor in
                        ServiceContainer.shared.securityLogManager.logEntry(
                            eventType: "connection_rate_exceeded",
                            source: "MeshManager",
                            severity: SecurityLogSeverity.error,
                            details: "é€£ç·šé€Ÿç‡ä¿è­·è§¸ç™¼ - PeerID: \(peerID), è¨Šæ¯é¡å‹: \(message.type.rawValue)"
                        )
                    }
                    
                    // é€šçŸ¥å®‰å…¨ç›£æ§ç³»çµ±
                    Task {
                        await notifySecurityHealthMonitor(
                            event: .connectionRateProtection,
                            peerID: peerID,
                            details: "Message blocked by connection rate protection (Type: \(message.type.rawValue))"
                        )
                    }
                    return
                }
            } else {
                print("ğŸš¨ Emergency/System message bypass: \(message.type.rawValue) from \(peerID)")
            }
            
            // ğŸ§  APT é˜²ç¦¦ç³»çµ±åˆ†æï¼ˆç·Šæ€¥è¨Šæ¯å’ŒéŠæˆ²è¨Šæ¯ç¹éï¼‰
            if !shouldBypassConnectionRateProtection(message: message, from: peerID) && !isGameCommunication(message: message) {
                let anomalyLevel = await MainActor.run {
                    ServiceContainer.shared.behaviorAnalysisSystem.analyzeMessage(
                        from: peerID,
                        content: String(data: message.data, encoding: .utf8) ?? ""
                    )
                }
                
                if anomalyLevel == .dangerous {
                    print("ğŸ›¡ï¸ APT Defence: Blocked dangerous connection from \(peerID)")
                    
                    // è¨˜éŒ„çµ±è¨ˆ
                    networkStats.blockedMessages += 1
                    networkStats.lastBlockedPeer = peerID
                    networkStats.lastBlockedTime = Date()
                    
                    // è¨˜éŒ„åˆ°å®‰å…¨æ—¥èªŒï¼ˆå·²åœ¨ BehaviorAnalysisSystem ä¸­è‡ªå‹•è¨˜éŒ„ï¼‰
                    
                    return
                } else if anomalyLevel == .suspicious {
                    print("âš ï¸ Behavior Analysis: Suspicious activity detected from \(peerID) - monitoring")
                }
            } else if isGameCommunication(message: message) {
                print("ğŸ® éŠæˆ²é€šè¨Šç™½åå–®ï¼šè·³éè¡Œç‚ºåˆ†æ - \(message.type.rawValue) from \(peerID)")
            }
            
            // é‡è¤‡è¨Šæ¯æª¢æŸ¥ï¼ˆç·šç¨‹å®‰å…¨ï¼‰
            if containsProcessedMessage(message.id) {
                print("ğŸ” Duplicate message ignored: \(message.id)")
                return
            }
            
            // è¨˜éŒ„å·²è™•ç†è¨Šæ¯ï¼ˆç·šç¨‹å®‰å…¨ï¼‰
            addToProcessedMessages(message.id)
            
            // è½‰æ›ç‚º ExtendedMeshMessage
            let extendedMessage = ExtendedMeshMessage(
                type: ExtendedMeshMessageType(rawValue: message.type.stringValue) ?? .system,
                sourceID: message.sourceID ?? peerID,
                targetID: message.targetID,
                data: message.data,
                ttl: message.ttl
            )
            
            // è™•ç†è¨Šæ¯
            handleMeshMessage(extendedMessage, from: peerID)
            
            // å‘¼å«å”è­°å›èª¿
            onMessageReceived?(message)
            
            // æ›´æ–°çµ±è¨ˆ
            updateStats(for: message, isSent: false)
            
        } catch {
            print("âŒ Failed to process incoming data from \(peerID): \(error)")
        }
    }
    
    private func handleMeshMessage(_ message: ExtendedMeshMessage, from peerID: String) {
        let myID = networkService.myPeerID.displayName
        
        // æ›´æ–°ç¯€é»æŒ‡æ¨™ï¼ˆåŸºæ–¼å¿ƒè·³è¨Šæ¯ï¼‰
        if message.type == .heartbeat {
            updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºç›®æ¨™æ¥æ”¶è€…
        if let targetID = message.targetID {
            if targetID == myID {
                // ç›´æ¥è¨Šæ¯çµ¦æˆ‘
                deliverMessage(message)
                print("ğŸ“¨ Received direct \(message.type.rawValue) from \(message.sourceID)")
            } else {
                // éœ€è¦è½‰ç™¼
                forwardMessage(message, from: peerID)
            }
        } else {
            // å»£æ’­è¨Šæ¯
            if message.sourceID != myID {
                deliverMessage(message)
                forwardMessage(message, from: peerID)
                print("ğŸ“» Received broadcast \(message.type.rawValue) from \(message.sourceID)")
            }
        }
        
        // è™•ç†ç‰¹æ®Šè¨Šæ¯é¡å‹
        handleSpecialMessageTypes(message, from: peerID)
    }
    
    private func deliverMessage(_ message: ExtendedMeshMessage) {
        // ç·Šæ€¥è¨Šæ¯ç‰¹æ®Šè™•ç†
        if message.type.isEmergency {
            let meshMessageType = convertToMeshMessageType(message.type)
            onEmergencyMessage?(message.data, meshMessageType, message.sourceID)
        }
        
        // ä¸€èˆ¬è¨Šæ¯è™•ç†
        let meshMessage = MeshMessage(type: convertToMeshMessageType(message.type), sourceID: message.sourceID, targetID: message.targetID, data: message.data, ttl: message.ttl)
        onMessageReceived?(meshMessage)
        
        // ã€NEWã€‘éŠæˆ²è¨Šæ¯ç‰¹æ®Šè™•ç†
        if message.type == .game {
            onGameMessageReceived?(meshMessage)
        }
    }
    
    private func forwardMessage(_ message: ExtendedMeshMessage, from senderID: String) {
        guard message.ttl > 0 && !message.isExpired else {
            print("âš°ï¸ Message expired, not forwarding")
            return
        }
        
        // é¿å…è·¯ç”±å¾ªç’°
        let myID = networkService.myPeerID.displayName
        if message.routePath.contains(myID) {
            print("ğŸ”„ Avoiding routing loop for message \(message.id)")
            return
        }
        
        // å‰µå»ºè½‰ç™¼å‰¯æœ¬
        let forwardedMessage = message.forwarded(through: myID)
        
        // æ™ºèƒ½è½‰ç™¼æ±ºç­–
        let connectedPeerIDs = networkService.connectedPeers.map { $0.displayName }
        let validTargets = connectedPeerIDs.filter { 
            $0 != senderID && !message.routePath.contains($0) 
        }
        
        if !validTargets.isEmpty {
            let meshMessage = MeshMessage(type: convertToMeshMessageType(forwardedMessage.type), sourceID: forwardedMessage.sourceID, targetID: forwardedMessage.targetID, data: forwardedMessage.data, ttl: forwardedMessage.ttl)
            messageQueue.enqueue(meshMessage)
            
            // æ›´æ–°è½‰ç™¼çµ±è¨ˆ
            DispatchQueue.main.async {
                self.networkStats.messagesForwarded += 1
            }
            
            print("ğŸ”„ Queued message for forwarding to \(validTargets.count) peers")
        }
    }
    
    private func processOutgoingMessage(_ message: MeshMessage) {
        messageQueue.enqueue(message)
    }
    
    private func processMessageQueue() {
        guard let message = messageQueue.dequeue() else { return }
        
        if let targetID = message.targetID {
            // ç›´æ¥è¨Šæ¯ - ä½¿ç”¨æ™ºèƒ½è·¯ç”±
            routeDirectMessage(message, to: targetID)
        } else {
            // å»£æ’­è¨Šæ¯
            broadcastToConnectedPeers(message)
        }
    }
    
    private func routeDirectMessage(_ message: MeshMessage, to targetID: String) {
        let myID = networkService.myPeerID.displayName
        let connectedPeers = networkService.connectedPeers
        
        // æª¢æŸ¥æ˜¯å¦ç›´æ¥é€£æ¥
        if let targetPeer = connectedPeers.first(where: { $0.displayName == targetID }) {
            sendMessageToPeer(message, peer: targetPeer)
            return
        }
        
        // ä½¿ç”¨æ™ºèƒ½è·¯ç”±å°‹æ‰¾æœ€ä½³è·¯å¾‘
        if let route = intelligentRouter.findBestRoute(
            from: myID, 
            to: targetID, 
            topology: topology, 
            isEmergency: message.type.isEmergency
        ) {
            if route.count > 1 {
                let nextHop = route[1]
                if let peer = connectedPeers.first(where: { $0.displayName == nextHop }) {
                    sendMessageToPeer(message, peer: peer)
                    print("ğŸ›¤ï¸ Routed \(message.type.isEmergency ? "EMERGENCY " : "")\(message.type.rawValue) to \(targetID) via \(nextHop)")
                    return
                }
            }
        }
        
        print("ğŸš« No route found to \(targetID)")
    }
    
    private func broadcastToConnectedPeers(_ message: MeshMessage) {
        let connectedPeers = networkService.connectedPeers
        
        for peer in connectedPeers {
            // é¿å…å›å‚³çµ¦åŸå§‹ç™¼é€è€…
            if !message.routePath.contains(peer.displayName) {
                sendMessageToPeer(message, peer: peer)
            }
        }
    }
    
    private func sendMessageToPeer(_ message: MeshMessage, peer: MCPeerID) {
        Task {
            do {
                let messageData = try BinaryMessageEncoder.encode(message)
                
                // é¸æ“‡æ€§åŠ å¯†ï¼šå…¬é–‹è³‡è¨Šä¸åŠ å¯†ï¼Œéš±ç§è³‡è¨Šæ¢ä»¶åŠ å¯†
                let finalData: Data
                if shouldEncryptMessage(message) {
                    let hasKey = await securityService.hasSessionKey(for: peer.displayName)
                    if hasKey {
                        finalData = try await securityService.encrypt(messageData, for: peer.displayName)
                        print("ğŸ” å·²åŠ å¯†å‚³é€: \(message.type.stringValue) åˆ° \(peer.displayName)")
                    } else {
                        finalData = messageData
                        print("âš ï¸ ç„¡å¯†é‘°ï¼Œæ˜æ–‡å‚³é€éš±ç§è¨Šæ¯: \(message.type.stringValue)")
                    }
                } else {
                    finalData = messageData
                    print("ğŸ“¢ å…¬é–‹è³‡è¨Šæ˜æ–‡å‚³é€: \(message.type.stringValue)")
                }
                
                try await networkService.send(finalData, to: [peer])
                
                // ç™¼é€æˆåŠŸï¼Œæ¸…ç†å¤±æ•—è¨˜éŒ„
                clearSendFailure(for: peer.displayName)
                
            } catch {
                print("âŒ Failed to send message to \(peer.displayName): \(error)")
                
                // è¨˜éŒ„ç™¼é€å¤±æ•—ï¼Œä½†ä¸ç«‹å³æ¨™è¨˜ç‚ºå¤±æ•—
                recordSendFailure(for: peer.displayName)
            }
        }
    }
    
    private func handleSpecialMessageTypes(_ message: ExtendedMeshMessage, from peerID: String) {
        switch message.type {
        case .heartbeat:
            handleHeartbeat(message, from: peerID)
        case .routingUpdate:
            handleRoutingUpdate(message, from: peerID)
        case .keyExchange:
            let meshMessage = MeshMessage(type: convertToMeshMessageType(message.type), sourceID: message.sourceID, targetID: message.targetID, data: message.data, ttl: message.ttl)
            handleKeyExchange(meshMessage, from: peerID)
        default:
            break
        }
    }
    
    private func handleHeartbeat(_ message: ExtendedMeshMessage, from peerID: String) {
        // æ›´æ–°æ‹“æ’²é€£æ¥
        topology.addConnection(from: message.sourceID, to: peerID)
        updateConnectedPeers()
        
        // æ›´æ–°ç¯€é»æŒ‡æ¨™
        updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
    }
    
    // MARK: - ğŸš¨ ä¿¡è™Ÿæ•¸æ“šè™•ç†
    private func handleInlineSignalTuple(_ signalTuple: (type: SignalType, deviceName: String, deviceID: String, gridCode: String?, timestamp: Date), from peerID: String) async {
        print("ğŸš¨ è™•ç†å…§è¯ä¿¡è™Ÿæ•¸æ“š: é¡å‹=\(signalTuple.type), ä¾†æº=\(signalTuple.deviceName)")
        
        // è½‰ç™¼åˆ° ServiceContainer çš„ä¿¡è™Ÿè™•ç†ç³»çµ±
        await MainActor.run {
            _ = Task {
                await ServiceContainer.shared.routeInlineSignalTuple(signalTuple, from: peerID)
            }
        }
        
        // æ›´æ–°çµ±è¨ˆæ•¸æ“š
        networkStats.messagesReceived += 1
        
        // è¨˜éŒ„æˆåŠŸè™•ç†
        print("âœ… å…§è¯ä¿¡è™Ÿæ•¸æ“šè™•ç†å®Œæˆ")
    }
    
    private func handleRoutingUpdate(_ message: ExtendedMeshMessage, from peerID: String) {
        do {
            let remoteTopology = try BinaryMessageDecoder.decodeTopology(message.data, expectedType: .routingUpdate)
            
            // åˆä½µæ‹“æ’²ä¿¡æ¯
            for (node, connections) in remoteTopology {
                for connection in connections {
                    topology.addConnection(from: node, to: connection)
                }
            }
            
            updateConnectedPeers()
            
        } catch {
            print("âŒ Failed to process routing update from \(peerID): \(error)")
        }
    }
    
    private func handleKeyExchange(_ message: MeshMessage, from peerID: String) {
        print("ğŸ”‘ æ”¶åˆ°ä¾†è‡ª \(peerID) çš„å¯†é‘°äº¤æ›è«‹æ±‚")
        
        // è½‰ç™¼çµ¦ ServiceContainer ä½¿ç”¨åŸæœ‰çš„å¯†é‘°äº¤æ›è™•ç†é‚è¼¯
        Task { @MainActor in
            await ServiceContainer.shared.handleKeyExchangeMessage(message)
        }
    }
    
    private func handlePeerConnected(_ peerID: String) {
        // ğŸ§  APT é˜²ç¦¦ç³»çµ±åˆ†ææ–°é€£æ¥
        let anomalyLevel = ServiceContainer.shared.behaviorAnalysisSystem.analyzeConnection(from: peerID)
        
        if anomalyLevel == .dangerous {
            print("ğŸ›¡ï¸ APT Defence: Blocked dangerous peer connection - \(peerID)")
            
            // è¨˜éŒ„çµ±è¨ˆ
            networkStats.blockedConnections += 1
            ServiceContainer.shared.behaviorAnalysisSystem.blockedConnections += 1
            
            // è¨»è¨˜ï¼šå±éšªé€£æ¥å°‡è¢«ç›£æ§ï¼Œå¯¦éš›æ–·é–‹éœ€è¦æ›´è¤‡é›œçš„peerç®¡ç†
            // TODO: å¯¦ä½œçœŸæ­£çš„é€£æ¥æ–·é–‹æ©Ÿåˆ¶
            
            return
        } else if anomalyLevel == .suspicious {
            print("âš ï¸ APT Defence: Suspicious peer connected - \(peerID) - monitoring")
        }
        
        topology.addConnection(from: networkService.myPeerID.displayName, to: peerID)
        updateConnectedPeers()
        sendRoutingUpdate()
        
        // åˆå§‹åŒ–ç¯€é»æŒ‡æ¨™
        updateNodeMetrics(peerID: peerID, signalStrength: -50.0, packetLoss: 0.0)
        
        // 1. å ±å‘Šå°ç­‰é«”é€£æ¥åˆ°ç¶²æ ¼å±¤
        networkStateCoordinator.reportPeerConnection(peerID, connected: true, layer: .mesh)
        
        // 2. æª¢æŸ¥ä¸¦æ›´æ–°ç¶²æ ¼å±¤ç‹€æ…‹
        let currentPeerCount = getConnectedPeers().count
        if currentPeerCount > 0 {
            networkStateCoordinator.reportMeshLayerState(.ready, peerCount: currentPeerCount)
        }
        
        // ğŸ”‘ ä¸»å‹•å•Ÿå‹•å¯†é‘°äº¤æ›ä»¥æé«˜ç©©å®šæ€§
        Task { @MainActor in
            // çŸ­æš«å»¶é²ä»¥ç¢ºä¿é€£æ¥ç©©å®š
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5ç§’å»¶é²
            
            // æª¢æŸ¥é€£æ¥æ˜¯å¦ä»ç„¶æ´»èº
            if getConnectedPeers().contains(peerID) {
                print("ğŸ”‘ ä¸»å‹•å•Ÿå‹•èˆ‡ \(peerID) çš„å¯†é‘°äº¤æ›")
                await ServiceContainer.shared.scheduleKeyExchangeRetry(with: peerID)
            }
        }
        
        // å‘¼å«å”è­°å›èª¿
        onPeerConnected?(peerID)
        
        print("ğŸ¤ Peer connected: \(peerID)")
    }
    
    private func handlePeerDisconnected(_ peerID: String) {
        topology.removePeer(peerID)
        Task {
            await securityService.removeSessionKey(for: peerID)
        }
        intelligentRouter.markNodeAsFailed(peerID)
        
        // æ¸…ç†å¯†é‘°äº¤æ›ç‹€æ…‹
        ServiceContainer.shared.cleanupKeyExchangeState(for: peerID)
        
        updateConnectedPeers()
        sendRoutingUpdate()
        
        // 1. å ±å‘Šå°ç­‰é«”æ–·é–‹é€£æ¥
        networkStateCoordinator.reportPeerConnection(peerID, connected: false, layer: .mesh)
        
        // 2. æª¢æŸ¥ä¸¦æ›´æ–°ç¶²æ ¼å±¤ç‹€æ…‹
        let remainingPeerCount = getConnectedPeers().count
        if remainingPeerCount == 0 {
            networkStateCoordinator.reportMeshLayerState(.disconnected, peerCount: 0)
        } else {
            networkStateCoordinator.reportMeshLayerState(.ready, peerCount: remainingPeerCount)
        }
        
        // æ¸…ç†æŒ‡æ¨™
        DispatchQueue.main.async {
            self.routingMetrics.removeValue(forKey: peerID)
        }
        
        // å‘¼å«å”è­°å›èª¿
        onPeerDisconnected?(peerID)
        
        print("ğŸ‘‹ Peer disconnected: \(peerID)")
    }
    
    private func updateConnectedPeers() {
        DispatchQueue.main.async {
            self.connectedPeers = self.getConnectedPeers()
            self.networkStats.connectedPeersCount = self.connectedPeers.count
            self.onNetworkTopologyChanged?(self.getNetworkTopology())
        }
    }
    
    private func sendHeartbeat() {
        // ğŸš¨ ç½é›£é€šä¿¡å„ªåŒ–ï¼šæ™ºèƒ½å¿ƒè·³ç®¡ç†
        let connectedCount = networkService.connectedPeers.count
        
        // 1. å¦‚æœæ²’æœ‰é€£æ¥ï¼Œä¸ç™¼é€å¿ƒè·³ç¯€çœè³‡æº
        guard connectedCount > 0 else {
            print("ğŸ“± ç„¡é€£æ¥è¨­å‚™ï¼Œè·³éå¿ƒè·³")
            return
        }
        
        // 2. å‰µå»ºè¼•é‡ç´šå¿ƒè·³æ•¸æ“šï¼ˆåŒ…å«åŸºæœ¬æ‹“æ’²ä¿¡æ¯ï¼‰
        let myID = networkService.myPeerID.displayName
        let heartbeatInfo = "\(myID):\(connectedCount)"
        let heartbeatData = heartbeatInfo.data(using: .utf8) ?? Data()
        
        print("ğŸ’“ ç™¼é€å¿ƒè·³åˆ° \(connectedCount) å€‹è¨­å‚™")
        broadcastMessage(heartbeatData, messageType: .heartbeat)
    }
    
    private func sendRoutingUpdate() {
        do {
            let topologyDict = Dictionary(uniqueKeysWithValues: topology.getConnections().map { (key, value) in
                (key, Set(value))
            })
            let topologyData = try BinaryMessageEncoder.encodeTopology(topologyDict, messageType: .routingUpdate)
            broadcastMessage(topologyData, messageType: .routingUpdate)
        } catch {
            print("âŒ Failed to send routing update: \(error)")
        }
    }
    
    private func updateStats(for message: MeshMessage, isSent: Bool) {
        DispatchQueue.main.async {
            if isSent {
                self.networkStats.messagesSent += 1
                if message.type.isEmergency {
                    self.networkStats.emergencyMessagesSent += 1
                }
            } else {
                self.networkStats.messagesReceived += 1
                if message.type.isEmergency {
                    self.networkStats.emergencyMessagesReceived += 1
                }
            }
        }
    }
    
    // ç·šç¨‹å®‰å…¨çš„ processedMessages ç®¡ç†æ–¹æ³•
    private func containsProcessedMessage(_ messageID: String) -> Bool {
        return processedMessagesQueue.sync {
            _processedMessages.contains(messageID)
        }
    }
    
    private func addToProcessedMessages(_ messageID: String) {
        Task { @MainActor in
            self._processedMessages.insert(messageID)
            
            // é™åˆ¶è¨˜æ†¶é«”ä½¿ç”¨ - LRU æ¸…ç†ç­–ç•¥
            if self._processedMessages.count > self.processedMessagesLimit {
                let excess = self._processedMessages.count - self.processedMessagesLimit / 2
                let toRemove = Array(self._processedMessages.prefix(excess))
                
                for id in toRemove {
                    self._processedMessages.remove(id)
                }
                
                print("ğŸ§© Cleaned \(excess) old processed messages")
            }
        }
    }
    
    private func clearProcessedMessages() {
        Task { @MainActor in
            self._processedMessages.removeAll()
        }
    }
    
    private func performCleanup() {
        // æ¸…ç†æ™ºèƒ½è·¯ç”±å™¨
        intelligentRouter.cleanup()
        
        // æ¸…ç†ç·Šæ€¥è¨Šæ¯é€Ÿç‡é™åˆ¶å™¨
        emergencyRateLimiter.performCleanup()
        
        // æ›´æ–°ç¶²è·¯å¯é æ€§çµ±è¨ˆ
        updateNetworkReliability()
        
        print("ğŸ§¹ Performed periodic cleanup")
    }
    
    private func updateNetworkReliability() {
        let allMetrics = intelligentRouter.getAllNodeMetrics()
        let activeNodes = allMetrics.values.filter { $0.isReachable }
        
        if !activeNodes.isEmpty {
            let averageScore = activeNodes.reduce(0.0) { $0 + $1.routeScore } / Float(activeNodes.count)
            
            DispatchQueue.main.async {
                self.networkStats.networkReliability = averageScore
            }
        }
    }
}

// MARK: - String Extension for Repetition
extension String {
    static func * (left: String, right: Int) -> String {
        return String(repeating: left, count: right)
    }
}

// MARK: - Backward Compatibility API
extension MeshManager {
    // å‘å¾Œå…¼å®¹çš„APIæ–¹æ³•ï¼Œè®“èˆŠçš„ViewModelèƒ½å¤ æ­£å¸¸å·¥ä½œ
    
    /// å‘å¾Œå…¼å®¹çš„ç°¡å–®åˆå§‹åŒ–å™¨
    convenience init() {
        // å‰µå»ºç°¡å–®çš„å¯¦ç¾ä½œç‚ºæ›¿ä»£
        let dummyNetworkService = DummyNetworkService()
        let _ = DummySecurityService() // ç”¨æ–¼å‘å¾Œå…¼å®¹æ€§
        
        // ä½¿ç”¨é«˜ç´šé€£ç·šé€Ÿç‡ç®¡ç†ä½œç‚ºé»˜èªé¸é …
        let advancedProtection = ConnectionRateManager()
        
        self.init(
            networkService: dummyNetworkService,
            securityService: SecurityService(),
            trustScoreManager: TrustScoreManager(),
            connectionRateManager: nil,
            advancedConnectionRateManager: advancedProtection
        )
        print("ğŸ•¸ï¸ MeshManager initialized with dummy services and advanced connection rate manager (backward compatibility)")
    }
    
    /// å•Ÿå‹•Meshç¶²è·¯ï¼ˆå…¼å®¹èˆŠAPIï¼‰
    func startMeshNetworkLegacy() {
        // æ–°ç‰ˆæœ¬åœ¨åˆå§‹åŒ–æ™‚è‡ªå‹•å•Ÿå‹•ï¼Œé€™è£¡åªæ˜¯è¨˜éŒ„
        print("ğŸ•¸ï¸ MeshManager: Legacy startMeshNetwork() called")
    }
    
    
    /// è¨­ç½®è¨Šæ¯è™•ç†å™¨ï¼ˆå…¼å®¹èˆŠAPIï¼‰
    func setMessageHandler(_ handler: @escaping (Data) -> Void) {
        onMessageReceived = { message in
            handler(message.data)
        }
        print("ğŸ•¸ï¸ MeshManager: Legacy message handler set")
    }
    
    /// å»£æ’­è¨Šæ¯ï¼ˆå…¼å®¹èˆŠAPIï¼‰
    func broadcast(_ data: Data, priority: MessagePriority, userNickname: String) async throws {
        // å°‡èˆŠçš„å„ªå…ˆç´šæ˜ å°„åˆ°æ–°çš„è¨Šæ¯é¡å‹
        let messageType: MeshMessageType
        switch priority {
        case .emergency:
            messageType = .emergency  // ç·Šæ€¥è¨Šæ¯
        case .high:
            messageType = .signal
        case .normal:
            messageType = .chat
        case .low:
            messageType = .system
        }
        
        broadcastMessage(data, messageType: messageType)
        print("ğŸ•¸ï¸ MeshManager: Legacy broadcast called with priority \(priority)")
    }
}

// MARK: - Dummy Implementations for Backward Compatibility
@MainActor
class DummyNetworkService: NetworkServiceProtocol {
    var isConnected: Bool = false
    var myPeerID: MCPeerID = MCPeerID(displayName: "DummyPeer")
    var connectedPeers: [MCPeerID] = []
    var onDataReceived: ((Data, String) -> Void)?
    var onPeerConnected: ((String) -> Void)?
    var onPeerDisconnected: ((String) -> Void)?
    
    func startNetworking() {
        print("ğŸ”§ DummyNetworkService: startNetworking called (no-op)")
    }
    
    func stopNetworking() {
        print("ğŸ”§ DummyNetworkService: stopNetworking called (no-op)")
    }
    
    func send(_ data: Data, to peers: [MCPeerID]) async throws {
        print("ğŸ”§ DummyNetworkService: send called (no-op)")
    }
}

class DummySecurityService: SecurityServiceProtocol {
    func generateSessionKey() -> Data? { return Data() }
    func encryptData(_ data: Data) -> Data? { return data }
    func decryptData(_ data: Data) -> Data? { return data }
    func hasSessionKey(for peerID: String) async -> Bool { return false }
    func encrypt(_ data: Data, for peerID: String) throws -> Data { return data }
    func decrypt(_ data: Data, from peerID: String) throws -> Data { return data }
    func getPublicKey() throws -> Data { return Data() }
    func removeSessionKey(for peerID: String) {}
} 
