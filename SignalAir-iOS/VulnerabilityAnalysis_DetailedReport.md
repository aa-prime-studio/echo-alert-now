# ğŸ” æ¼æ´è©³ç´°åˆ†æå ±å‘Šèˆ‡è£œå¼·æ–¹æ¡ˆ

## ğŸ“‹ ç¸½è¦½
æœ¬å ±å‘Šè©³ç´°åˆ†æè‡ªå‹•åŒ–æ»²é€æ¸¬è©¦ä¸­ç™¼ç¾çš„8å€‹å®‰å…¨æ¼æ´ï¼ŒåŒ…æ‹¬ç™¼ç¾åŸå› ã€é¢¨éšªè©•ä¼°å’Œå…·é«”çš„è£œå¼·å¯¦æ–½æ–¹æ¡ˆã€‚

---

## ğŸš¨ æ¼æ´ä¸€ï¼šé€£æ¥é€Ÿç‡é™åˆ¶ä¸è¶³

### ğŸ” ç™¼ç¾åŸå› 
åœ¨ç¶²è·¯å±¤æ”»æ“Šæ¸¬è©¦ä¸­ï¼Œç³»çµ±è¡¨ç¾å‡ºä»¥ä¸‹å•é¡Œï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šæ¨¡æ“¬æ¯ç§’1000å€‹é€£æ¥è«‹æ±‚çš„DDoSæ”»æ“Š
- **ç™¼ç¾å•é¡Œ**ï¼š
  - é€£æ¥é€Ÿç‡é™åˆ¶æ©Ÿåˆ¶æœªèƒ½æœ‰æ•ˆé˜»æ­¢é«˜é »é€£æ¥
  - ç³»çµ±åœ¨çŸ­æ™‚é–“å…§æ¥å—äº†éå¤šé€£æ¥è«‹æ±‚
  - è³‡æºæ¶ˆè€—å¿«é€Ÿå¢åŠ ï¼Œå¯èƒ½å°è‡´æœå‹™æ‹’çµ•

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé«˜
- **å¯åˆ©ç”¨æ€§**ï¼šé«˜
- **å½±éŸ¿ç¯„åœ**ï¼šç¶²è·¯å±¤ã€ç³»çµ±ç©©å®šæ€§
- **æ”»æ“Šé›£åº¦**ï¼šä½

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½å‹•æ…‹é€£æ¥é€Ÿç‡é™åˆ¶
```swift
// åœ¨ NetworkService.swift ä¸­æ·»åŠ é€Ÿç‡é™åˆ¶å™¨
class ConnectionRateLimiter {
    private let maxConnectionsPerSecond: Int = 10
    private let maxConnectionsPerMinute: Int = 100
    private let timeWindow: TimeInterval = 60.0
    
    private var connectionHistory: [String: [Date]] = [:]
    private let queue = DispatchQueue(label: "ConnectionRateLimiter", qos: .userInitiated)
    
    func canAcceptConnection(from peerID: String) -> Bool {
        return queue.sync {
            let now = Date()
            let cutoffTime = now.addingTimeInterval(-timeWindow)
            
            // æ¸…ç†éæœŸè¨˜éŒ„
            connectionHistory[peerID] = connectionHistory[peerID]?.filter { $0 > cutoffTime } ?? []
            
            // æª¢æŸ¥é€£æ¥é »ç‡
            let recentConnections = connectionHistory[peerID]?.count ?? 0
            let lastSecondConnections = connectionHistory[peerID]?.filter { 
                $0 > now.addingTimeInterval(-1.0) 
            }.count ?? 0
            
            guard recentConnections < maxConnectionsPerMinute && 
                  lastSecondConnections < maxConnectionsPerSecond else {
                print("ğŸš« é€£æ¥è¢«é€Ÿç‡é™åˆ¶å™¨æ‹’çµ•: \(peerID)")
                return false
            }
            
            // è¨˜éŒ„æ–°é€£æ¥
            connectionHistory[peerID, default: []].append(now)
            return true
        }
    }
}
```

#### 2. å¢å¼·é€£æ¥ç›£æ§å’Œå‘Šè­¦
```swift
// æ·»åŠ é€£æ¥ç›£æ§å™¨
class ConnectionMonitor {
    private var connectionStats: [String: ConnectionStats] = [:]
    private let alertThreshold: Int = 50
    
    func recordConnection(_ peerID: String) {
        let stats = connectionStats[peerID] ?? ConnectionStats()
        stats.totalConnections += 1
        stats.lastConnectionTime = Date()
        
        if stats.totalConnections > alertThreshold {
            triggerSecurityAlert(peerID: peerID, reason: "ç•°å¸¸é€£æ¥é »ç‡")
        }
        
        connectionStats[peerID] = stats
    }
    
    private func triggerSecurityAlert(peerID: String, reason: String) {
        // è§¸ç™¼å®‰å…¨å‘Šè­¦
        NotificationCenter.default.post(
            name: .securityAlert,
            object: SecurityAlert(level: .high, source: peerID, reason: reason)
        )
    }
}
```

#### 3. å¯¦æ–½æŒ‡æ•¸é€€é¿æ©Ÿåˆ¶
```swift
// åœ¨ NetworkService.swift ä¸­ä¿®æ”¹é€£æ¥è™•ç†
extension NetworkService {
    func handleConnectionRequest(from peerID: MCPeerID) -> Bool {
        let peerName = peerID.displayName
        
        // æª¢æŸ¥é€Ÿç‡é™åˆ¶
        guard rateLimiter.canAcceptConnection(from: peerName) else {
            // å¯¦æ–½æŒ‡æ•¸é€€é¿
            let backoffTime = calculateBackoffTime(for: peerName)
            scheduleConnectionRetry(for: peerID, after: backoffTime)
            return false
        }
        
        // è¨˜éŒ„é€£æ¥çµ±è¨ˆ
        connectionMonitor.recordConnection(peerName)
        return true
    }
    
    private func calculateBackoffTime(for peerName: String) -> TimeInterval {
        let retryCount = getRetryCount(for: peerName)
        return min(pow(2.0, Double(retryCount)), 60.0) // æœ€å¤§60ç§’
    }
}
```

---

## ğŸš¨ æ¼æ´äºŒï¼šä¿¡ä»»è©•åˆ†ç•°å¸¸æª¢æ¸¬æ©Ÿåˆ¶ä¸è¶³

### ğŸ” ç™¼ç¾åŸå› 
åœ¨ä¿¡ä»»è©•åˆ†ç³»çµ±æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šæ¨¡æ“¬äººå·¥è£½é€ æ­£é¢è¡Œç‚ºä¾†æå‡ä¿¡ä»»è©•åˆ†
- **ç™¼ç¾å•é¡Œ**ï¼š
  - ç¼ºä¹ç•°å¸¸è¡Œç‚ºæ¨¡å¼æª¢æ¸¬
  - è©•åˆ†è®ŠåŒ–ç›£æ§ä¸å¤ æ•æ„Ÿ
  - ç„¡æ³•è­˜åˆ¥å”èª¿æ€§æ“ç¸±æ”»æ“Š

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé«˜
- **å¯åˆ©ç”¨æ€§**ï¼šä¸­
- **å½±éŸ¿ç¯„åœ**ï¼šä¿¡ä»»ç³»çµ±å®Œæ•´æ€§
- **æ”»æ“Šé›£åº¦**ï¼šä¸­

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½ä¿¡ä»»è©•åˆ†ç•°å¸¸æª¢æ¸¬
```swift
// åœ¨ TrustScoreManager.swift ä¸­æ·»åŠ ç•°å¸¸æª¢æ¸¬
class TrustScoreAnomalyDetector {
    private let normalScoreChangeThreshold: Double = 5.0
    private let rapidChangeTimeWindow: TimeInterval = 300.0 // 5åˆ†é˜
    private let suspiciousPatternThreshold: Int = 3
    
    private var scoreHistory: [String: [TrustScoreChange]] = [:]
    
    func detectAnomalies(for deviceUUID: String, change: Double, reason: ScoreChangeReason) -> Bool {
        let scoreChange = TrustScoreChange(
            change: change,
            reason: reason,
            timestamp: Date()
        )
        
        // è¨˜éŒ„è©•åˆ†è®ŠåŒ–
        scoreHistory[deviceUUID, default: []].append(scoreChange)
        
        // æª¢æŸ¥ç•°å¸¸æ¨¡å¼
        return checkRapidScoreIncrease(for: deviceUUID) ||
               checkSuspiciousPatterns(for: deviceUUID) ||
               checkCoordinatedManipulation(for: deviceUUID)
    }
    
    private func checkRapidScoreIncrease(for deviceUUID: String) -> Bool {
        let recentChanges = getRecentChanges(for: deviceUUID, within: rapidChangeTimeWindow)
        let totalPositiveChange = recentChanges.filter { $0.change > 0 }.reduce(0) { $0 + $1.change }
        
        if totalPositiveChange > normalScoreChangeThreshold {
            print("âš ï¸ æª¢æ¸¬åˆ°ç•°å¸¸å¿«é€Ÿè©•åˆ†æå‡: \(deviceUUID)")
            return true
        }
        
        return false
    }
    
    private func checkSuspiciousPatterns(for deviceUUID: String) -> Bool {
        let recentChanges = getRecentChanges(for: deviceUUID, within: rapidChangeTimeWindow)
        
        // æª¢æŸ¥é‡è¤‡æ€§è¡Œç‚ºæ¨¡å¼
        let reasonCounts = Dictionary(grouping: recentChanges) { $0.reason }
        let maxRepeats = reasonCounts.values.map { $0.count }.max() ?? 0
        
        if maxRepeats > suspiciousPatternThreshold {
            print("âš ï¸ æª¢æ¸¬åˆ°å¯ç–‘é‡è¤‡è¡Œç‚ºæ¨¡å¼: \(deviceUUID)")
            return true
        }
        
        return false
    }
    
    private func checkCoordinatedManipulation(for deviceUUID: String) -> Bool {
        // æª¢æŸ¥æ˜¯å¦æœ‰å¤šå€‹è¨­å‚™åŒæ™‚é€²è¡Œé¡ä¼¼æ“ä½œ
        let timeWindow = Date().addingTimeInterval(-rapidChangeTimeWindow)
        let suspiciousDevices = scoreHistory.filter { (_, changes) in
            changes.last?.timestamp ?? Date.distantPast > timeWindow
        }.count
        
        if suspiciousDevices > 5 {
            print("âš ï¸ æª¢æ¸¬åˆ°å¯èƒ½çš„å”èª¿æ€§æ“ç¸±æ”»æ“Š")
            return true
        }
        
        return false
    }
}
```

#### 2. å¢å¼·è©•åˆ†é©—è­‰æ©Ÿåˆ¶
```swift
// ä¿®æ”¹ TrustScoreManager.swift ä¸­çš„è©•åˆ†æ›´æ–°é‚è¼¯
func updateTrustScore(for deviceUUID: String, change: Double, reason: ScoreChangeReason) {
    // ç•°å¸¸æª¢æ¸¬
    if anomalyDetector.detectAnomalies(for: deviceUUID, change: change, reason: reason) {
        // è§¸ç™¼å®‰å…¨å¯©æ ¸
        triggerSecurityAudit(deviceUUID: deviceUUID, reason: "ä¿¡ä»»è©•åˆ†ç•°å¸¸è®ŠåŒ–")
        
        // æš«åœè©•åˆ†æ›´æ–°
        quarantineDevice(deviceUUID: deviceUUID, duration: 300) // 5åˆ†é˜éš”é›¢
        return
    }
    
    // æ­£å¸¸è©•åˆ†æ›´æ–°æµç¨‹
    performNormalScoreUpdate(for: deviceUUID, change: change, reason: reason)
}

private func triggerSecurityAudit(deviceUUID: String, reason: String) {
    let auditRecord = SecurityAuditRecord(
        deviceUUID: deviceUUID,
        reason: reason,
        timestamp: Date(),
        requiresManualReview: true
    )
    
    securityAuditQueue.append(auditRecord)
    
    // é€šçŸ¥å®‰å…¨ç›£æ§ç³»çµ±
    NotificationCenter.default.post(
        name: .trustScoreAuditRequired,
        object: auditRecord
    )
}
```

#### 3. å¯¦æ–½è©•åˆ†è®ŠåŒ–ç›£æ§
```swift
// æ·»åŠ è©•åˆ†è®ŠåŒ–ç›£æ§
class TrustScoreMonitor {
    private let monitoringInterval: TimeInterval = 60.0
    private var monitoringTimer: Timer?
    
    func startMonitoring() {
        monitoringTimer = Timer.scheduledTimer(withTimeInterval: monitoringInterval, repeats: true) { _ in
            self.performPeriodicCheck()
        }
    }
    
    private func performPeriodicCheck() {
        let anomalousDevices = detectAnomalousScorePatterns()
        
        for deviceUUID in anomalousDevices {
            // é™ä½å¯ç–‘è¨­å‚™çš„ä¿¡ä»»è©•åˆ†
            adjustTrustScore(for: deviceUUID, adjustment: -10.0, reason: .suspiciousActivity)
            
            // è¨˜éŒ„å®‰å…¨äº‹ä»¶
            logSecurityEvent(
                type: .trustScoreAnomaly,
                deviceUUID: deviceUUID,
                details: "æª¢æ¸¬åˆ°ä¿¡ä»»è©•åˆ†ç•°å¸¸æ¨¡å¼"
            )
        }
    }
}
```

---

## ğŸš¨ æ¼æ´ä¸‰ï¼šé›¶æ—¥æ”»æ“Šæª¢æ¸¬èƒ½åŠ›éœ€è¦å¢å¼·

### ğŸ” ç™¼ç¾åŸå› 
åœ¨æƒ¡æ„å…§å®¹æª¢æ¸¬æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šæ¨¡æ“¬æœªçŸ¥çš„æ”»æ“Šæ¨¡å¼å’Œæ–°å‹æ”»æ“Šè¼‰è·
- **ç™¼ç¾å•é¡Œ**ï¼š
  - åƒ…ä¾è³´ç°½åæª¢æ¸¬ï¼Œç„¡æ³•è­˜åˆ¥æ–°å‹æ”»æ“Š
  - ç¼ºä¹è¡Œç‚ºåˆ†æèƒ½åŠ›
  - æ©Ÿå™¨å­¸ç¿’æ¨¡å‹è¦†è“‹ä¸è¶³

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé«˜
- **å¯åˆ©ç”¨æ€§**ï¼šé«˜
- **å½±éŸ¿ç¯„åœ**ï¼šå…§å®¹å®‰å…¨ã€ç³»çµ±å®Œæ•´æ€§
- **æ”»æ“Šé›£åº¦**ï¼šé«˜

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½è¡Œç‚ºåˆ†æå¼•æ“
```swift
// å‰µå»ºè¡Œç‚ºåˆ†æå¼•æ“
class BehaviorAnalysisEngine {
    private let suspiciousPatterns: [BehaviorPattern] = [
        .rapidDataTransmission,
        .unusualMessageFrequency,
        .abnormalDataSize,
        .suspiciousTimingPatterns
    ]
    
    func analyzeMessage(_ message: Data, from sender: String) -> ThreatAnalysisResult {
        var suspiciousScore: Double = 0.0
        var detectedPatterns: [BehaviorPattern] = []
        
        // åˆ†ææ¶ˆæ¯å¤§å°
        if message.count > 1024 * 1024 { // 1MB
            suspiciousScore += 20.0
            detectedPatterns.append(.abnormalDataSize)
        }
        
        // åˆ†æç™¼é€é »ç‡
        if isHighFrequencySender(sender) {
            suspiciousScore += 15.0
            detectedPatterns.append(.unusualMessageFrequency)
        }
        
        // åˆ†æå…§å®¹ç‰¹å¾µ
        let contentAnalysis = analyzeMessageContent(message)
        suspiciousScore += contentAnalysis.riskScore
        detectedPatterns.append(contentsOf: contentAnalysis.patterns)
        
        // åˆ†ææ™‚é–“æ¨¡å¼
        if hasAbnormalTimingPattern(sender) {
            suspiciousScore += 10.0
            detectedPatterns.append(.suspiciousTimingPatterns)
        }
        
        return ThreatAnalysisResult(
            riskScore: suspiciousScore,
            threatLevel: determineThreatLevel(suspiciousScore),
            detectedPatterns: detectedPatterns,
            recommendation: generateRecommendation(suspiciousScore)
        )
    }
    
    private func analyzeMessageContent(_ message: Data) -> ContentAnalysisResult {
        var riskScore: Double = 0.0
        var patterns: [BehaviorPattern] = []
        
        // æª¢æŸ¥æ˜¯å¦åŒ…å«å¯åŸ·è¡Œå…§å®¹
        if containsExecutableContent(message) {
            riskScore += 30.0
            patterns.append(.executableContent)
        }
        
        // æª¢æŸ¥æ˜¯å¦åŒ…å«ç³»çµ±å‘½ä»¤
        if containsSystemCommands(message) {
            riskScore += 25.0
            patterns.append(.systemCommands)
        }
        
        // æª¢æŸ¥æ˜¯å¦åŒ…å«ç·¨ç¢¼å…§å®¹
        if containsEncodedContent(message) {
            riskScore += 15.0
            patterns.append(.encodedContent)
        }
        
        return ContentAnalysisResult(riskScore: riskScore, patterns: patterns)
    }
}
```

#### 2. å¯¦æ–½æ©Ÿå™¨å­¸ç¿’æª¢æ¸¬æ¨¡å‹
```swift
// æ©Ÿå™¨å­¸ç¿’å¨è„…æª¢æ¸¬æ¨¡å‹
class MLThreatDetector {
    private var featureExtractor: FeatureExtractor
    private var anomalyDetector: AnomalyDetector
    private var threatClassifier: ThreatClassifier
    
    init() {
        self.featureExtractor = FeatureExtractor()
        self.anomalyDetector = AnomalyDetector()
        self.threatClassifier = ThreatClassifier()
    }
    
    func detectThreat(in message: Data, from sender: String) -> MLThreatResult {
        // æå–ç‰¹å¾µ
        let features = featureExtractor.extractFeatures(from: message, sender: sender)
        
        // ç•°å¸¸æª¢æ¸¬
        let anomalyScore = anomalyDetector.calculateAnomalyScore(features)
        
        // å¨è„…åˆ†é¡
        let threatCategory = threatClassifier.classify(features)
        
        // ç¶œåˆè©•ä¼°
        let overallRiskScore = calculateOverallRisk(
            anomalyScore: anomalyScore,
            threatCategory: threatCategory,
            features: features
        )
        
        return MLThreatResult(
            riskScore: overallRiskScore,
            anomalyScore: anomalyScore,
            threatCategory: threatCategory,
            confidence: calculateConfidence(features),
            features: features
        )
    }
    
    // åœ¨ç·šå­¸ç¿’æ›´æ–°æ¨¡å‹
    func updateModel(with feedback: ThreatFeedback) {
        threatClassifier.updateWeights(feedback)
        anomalyDetector.adjustThresholds(feedback)
    }
}
```

#### 3. å¯¦æ–½å•Ÿç™¼å¼æª¢æ¸¬
```swift
// å•Ÿç™¼å¼æª¢æ¸¬å¼•æ“
class HeuristicDetector {
    private let heuristicRules: [HeuristicRule] = [
        .checkForPolymorphicCode,
        .detectMetamorphicPatterns,
        .analyzeControlFlowAnomalies,
        .checkForPackingTechniques
    ]
    
    func performHeuristicAnalysis(_ message: Data) -> HeuristicAnalysisResult {
        var detectedThreats: [HeuristicThreat] = []
        var totalRiskScore: Double = 0.0
        
        for rule in heuristicRules {
            let result = executeHeuristicRule(rule, on: message)
            if result.threatDetected {
                detectedThreats.append(result.threat)
                totalRiskScore += result.riskScore
            }
        }
        
        return HeuristicAnalysisResult(
            detectedThreats: detectedThreats,
            totalRiskScore: totalRiskScore,
            analysisTime: Date()
        )
    }
    
    private func executeHeuristicRule(_ rule: HeuristicRule, on message: Data) -> HeuristicRuleResult {
        switch rule {
        case .checkForPolymorphicCode:
            return checkPolymorphicCode(message)
        case .detectMetamorphicPatterns:
            return detectMetamorphicPatterns(message)
        case .analyzeControlFlowAnomalies:
            return analyzeControlFlowAnomalies(message)
        case .checkForPackingTechniques:
            return checkPackingTechniques(message)
        }
    }
}
```

---

## ğŸš¨ æ¼æ´å››ï¼šå…§éƒ¨å¨è„…æª¢æ¸¬æ©Ÿåˆ¶ç¼ºå¤±

### ğŸ” ç™¼ç¾åŸå› 
åœ¨ç¶œåˆæ”»æ“Šå ´æ™¯æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šæ¨¡æ“¬å¯ä¿¡ç”¨æˆ¶çš„æƒ¡æ„è¡Œç‚º
- **ç™¼ç¾å•é¡Œ**ï¼š
  - ç¼ºä¹å…§éƒ¨è¡Œç‚ºç›£æ§
  - ç„¡æ³•æª¢æ¸¬æ¬Šé™æ¿«ç”¨
  - æœªå¯¦æ–½ç•°å¸¸å­˜å–æ¨¡å¼åˆ†æ

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé—œéµ
- **å¯åˆ©ç”¨æ€§**ï¼šä¸­
- **å½±éŸ¿ç¯„åœ**ï¼šæ•´å€‹ç³»çµ±
- **æ”»æ“Šé›£åº¦**ï¼šä½

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½å…§éƒ¨å¨è„…æª¢æ¸¬ç³»çµ±
```swift
// å…§éƒ¨å¨è„…æª¢æ¸¬ç³»çµ±
class InsiderThreatDetector {
    private let behaviorAnalyzer = InsiderBehaviorAnalyzer()
    private let accessMonitor = AccessPatternMonitor()
    private let riskCalculator = InsiderRiskCalculator()
    
    func monitorUserActivity(_ activity: UserActivity) {
        // åˆ†æè¡Œç‚ºæ¨¡å¼
        let behaviorAnalysis = behaviorAnalyzer.analyzeActivity(activity)
        
        // ç›£æ§å­˜å–æ¨¡å¼
        let accessAnalysis = accessMonitor.analyzeAccess(activity)
        
        // è¨ˆç®—é¢¨éšªè©•åˆ†
        let riskScore = riskCalculator.calculateRisk(
            behavior: behaviorAnalysis,
            access: accessAnalysis
        )
        
        // æª¢æŸ¥æ˜¯å¦è§¸ç™¼å‘Šè­¦
        if riskScore > InsiderThreatThreshold.high {
            triggerInsiderThreatAlert(
                userID: activity.userID,
                riskScore: riskScore,
                reasons: combineAnalysisReasons(behaviorAnalysis, accessAnalysis)
            )
        }
    }
    
    private func triggerInsiderThreatAlert(userID: String, riskScore: Double, reasons: [String]) {
        let alert = InsiderThreatAlert(
            userID: userID,
            riskScore: riskScore,
            reasons: reasons,
            timestamp: Date(),
            severity: determineSeverity(riskScore)
        )
        
        // ç«‹å³é€šçŸ¥å®‰å…¨åœ˜éšŠ
        SecurityNotificationCenter.shared.sendAlert(alert)
        
        // è¨˜éŒ„åˆ°å®‰å…¨æ—¥èªŒ
        SecurityLogger.shared.logInsiderThreat(alert)
        
        // å¯é¸ï¼šè‡ªå‹•æ¡å–é˜²è­·æªæ–½
        if riskScore > InsiderThreatThreshold.critical {
            implementAutomaticCountermeasures(for: userID)
        }
    }
}
```

#### 2. å¯¦æ–½è¡Œç‚ºåŸºç·šåˆ†æ
```swift
// ç”¨æˆ¶è¡Œç‚ºåŸºç·šåˆ†æ
class UserBehaviorBaseline {
    private var userBaselines: [String: BehaviorBaseline] = [:]
    private let learningPeriod: TimeInterval = 30 * 24 * 3600 // 30å¤©
    
    func establishBaseline(for userID: String, activities: [UserActivity]) {
        let baseline = BehaviorBaseline(
            averageLoginTime: calculateAverageLoginTime(activities),
            commonAccessPatterns: identifyCommonPatterns(activities),
            typicalDataVolume: calculateTypicalDataVolume(activities),
            usualWorkingHours: identifyWorkingHours(activities),
            commonDevices: identifyCommonDevices(activities)
        )
        
        userBaselines[userID] = baseline
    }
    
    func detectDeviations(for userID: String, currentActivity: UserActivity) -> [BehaviorDeviation] {
        guard let baseline = userBaselines[userID] else {
            return [] // åŸºç·šæœªå»ºç«‹
        }
        
        var deviations: [BehaviorDeviation] = []
        
        // æª¢æŸ¥ç™»å…¥æ™‚é–“ç•°å¸¸
        if isUnusualLoginTime(currentActivity.loginTime, baseline: baseline) {
            deviations.append(.unusualLoginTime)
        }
        
        // æª¢æŸ¥å­˜å–æ¨¡å¼ç•°å¸¸
        if isUnusualAccessPattern(currentActivity.accessPattern, baseline: baseline) {
            deviations.append(.unusualAccessPattern)
        }
        
        // æª¢æŸ¥æ•¸æ“šé‡ç•°å¸¸
        if isUnusualDataVolume(currentActivity.dataVolume, baseline: baseline) {
            deviations.append(.unusualDataVolume)
        }
        
        // æª¢æŸ¥å·¥ä½œæ™‚é–“ç•°å¸¸
        if isOutsideWorkingHours(currentActivity.timestamp, baseline: baseline) {
            deviations.append(.outsideWorkingHours)
        }
        
        return deviations
    }
}
```

#### 3. å¯¦æ–½æ¬Šé™æ¿«ç”¨æª¢æ¸¬
```swift
// æ¬Šé™æ¿«ç”¨æª¢æ¸¬
class PrivilegeAbuseDetector {
    private let privilegeMonitor = PrivilegeMonitor()
    private let accessLogger = AccessLogger()
    
    func detectPrivilegeAbuse(for userID: String, action: UserAction) -> PrivilegeAbuseResult {
        // æª¢æŸ¥æ¬Šé™ä½¿ç”¨æ˜¯å¦åˆç†
        let privilegeCheck = privilegeMonitor.checkPrivilegeUsage(userID, action)
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ç•°å¸¸çš„æ¬Šé™æå‡
        let elevationCheck = checkPrivilegeElevation(userID, action)
        
        // æª¢æŸ¥æ˜¯å¦å­˜å–ä¸ç›¸é—œçš„è³‡æº
        let accessCheck = checkUnauthorizedAccess(userID, action)
        
        // è¨˜éŒ„æ‰€æœ‰æ¬Šé™ä½¿ç”¨
        accessLogger.logPrivilegeUsage(userID, action, Date())
        
        return PrivilegeAbuseResult(
            isAbusive: privilegeCheck.isAbusive || elevationCheck.isAbusive || accessCheck.isAbusive,
            reasons: combineReasons(privilegeCheck, elevationCheck, accessCheck),
            riskScore: calculatePrivilegeRisk(privilegeCheck, elevationCheck, accessCheck)
        )
    }
    
    private func checkPrivilegeElevation(_ userID: String, _ action: UserAction) -> PrivilegeCheckResult {
        let currentPrivileges = getCurrentPrivileges(userID)
        let requiredPrivileges = getRequiredPrivileges(action)
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦ä¸åˆç†çš„æ¬Šé™æå‡
        if requiredPrivileges.contains(where: { !currentPrivileges.contains($0) }) {
            return PrivilegeCheckResult(
                isAbusive: true,
                reason: "å˜—è©¦ä½¿ç”¨è¶…å‡ºæˆæ¬Šçš„æ¬Šé™"
            )
        }
        
        return PrivilegeCheckResult(isAbusive: false, reason: nil)
    }
}
```

---

## ğŸš¨ æ¼æ´äº”ï¼šAPTæ”»æ“Šæª¢æ¸¬èƒ½åŠ›éœ€è¦å¢å¼·

### ğŸ” ç™¼ç¾åŸå› 
åœ¨ç¶œåˆæ”»æ“Šå ´æ™¯æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šæ¨¡æ“¬180ç§’çš„APTæ”»æ“Šå ´æ™¯
- **ç™¼ç¾å•é¡Œ**ï¼š
  - ç„¡æ³•è­˜åˆ¥é•·æœŸæ½›ä¼å¨è„…
  - ç¼ºä¹æ”»æ“Šéˆåˆ†æ
  - æœªå¯¦æ–½æŒçºŒå¨è„…ç›£æ§

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé—œéµ
- **å¯åˆ©ç”¨æ€§**ï¼šé«˜
- **å½±éŸ¿ç¯„åœ**ï¼šæ•´å€‹ç³»çµ±
- **æ”»æ“Šé›£åº¦**ï¼šé«˜

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½APTæª¢æ¸¬å¼•æ“
```swift
// APTæª¢æ¸¬å¼•æ“
class APTDetectionEngine {
    private let attackChainAnalyzer = AttackChainAnalyzer()
    private let persistentThreatMonitor = PersistentThreatMonitor()
    private let behaviorCorrelator = BehaviorCorrelator()
    
    func detectAPTActivity(_ activities: [SecurityEvent]) -> APTDetectionResult {
        // åˆ†ææ”»æ“Šéˆ
        let attackChains = attackChainAnalyzer.identifyAttackChains(activities)
        
        // æª¢æ¸¬æŒçºŒå¨è„…
        let persistentThreats = persistentThreatMonitor.detectPersistentActivities(activities)
        
        // è¡Œç‚ºé—œè¯åˆ†æ
        let correlatedBehaviors = behaviorCorrelator.correlateBehaviors(activities)
        
        // ç¶œåˆè©•ä¼°APTå¯èƒ½æ€§
        let aptProbability = calculateAPTProbability(
            attackChains: attackChains,
            persistentThreats: persistentThreats,
            correlatedBehaviors: correlatedBehaviors
        )
        
        return APTDetectionResult(
            probability: aptProbability,
            detectedChains: attackChains,
            persistentIndicators: persistentThreats,
            correlatedEvents: correlatedBehaviors,
            recommendedActions: generateAPTRecommendations(aptProbability)
        )
    }
}
```

#### 2. å¯¦æ–½æ”»æ“Šéˆåˆ†æ
```swift
// æ”»æ“Šéˆåˆ†æå™¨
class AttackChainAnalyzer {
    private let aptPatterns: [APTPattern] = [
        .reconnaissanceToInfiltration,
        .infiltrationToPersistence,
        .persistenceToLateralMovement,
        .lateralMovementToExfiltration
    ]
    
    func identifyAttackChains(_ events: [SecurityEvent]) -> [AttackChain] {
        var identifiedChains: [AttackChain] = []
        
        // æŒ‰æ™‚é–“æ’åºäº‹ä»¶
        let sortedEvents = events.sorted { $0.timestamp < $1.timestamp }
        
        // åˆ†æäº‹ä»¶åºåˆ—
        for pattern in aptPatterns {
            let matchedChains = findMatchingChains(pattern, in: sortedEvents)
            identifiedChains.append(contentsOf: matchedChains)
        }
        
        return identifiedChains
    }
    
    private func findMatchingChains(_ pattern: APTPattern, in events: [SecurityEvent]) -> [AttackChain] {
        var chains: [AttackChain] = []
        
        for startIndex in 0..<events.count {
            if let chain = buildChain(from: startIndex, pattern: pattern, events: events) {
                chains.append(chain)
            }
        }
        
        return chains
    }
    
    private func buildChain(from startIndex: Int, pattern: APTPattern, events: [SecurityEvent]) -> AttackChain? {
        let patternSteps = getPatternSteps(pattern)
        var chainEvents: [SecurityEvent] = []
        var currentIndex = startIndex
        
        for step in patternSteps {
            if let matchingEvent = findNextMatchingEvent(step, from: currentIndex, in: events) {
                chainEvents.append(matchingEvent)
                currentIndex = events.firstIndex(of: matchingEvent)! + 1
            } else {
                return nil // éˆæ–·è£‚
            }
        }
        
        return AttackChain(
            pattern: pattern,
            events: chainEvents,
            confidence: calculateChainConfidence(chainEvents),
            duration: chainEvents.last!.timestamp.timeIntervalSince(chainEvents.first!.timestamp)
        )
    }
}
```

#### 3. å¯¦æ–½æŒçºŒå¨è„…ç›£æ§
```swift
// æŒçºŒå¨è„…ç›£æ§
class PersistentThreatMonitor {
    private let monitoringWindow: TimeInterval = 7 * 24 * 3600 // 7å¤©
    private var longTermEvents: [SecurityEvent] = []
    
    func detectPersistentActivities(_ newEvents: [SecurityEvent]) -> [PersistentThreatIndicator] {
        // æ·»åŠ æ–°äº‹ä»¶åˆ°é•·æœŸç›£æ§
        longTermEvents.append(contentsOf: newEvents)
        
        // æ¸…ç†éæœŸäº‹ä»¶
        cleanupExpiredEvents()
        
        // åˆ†ææŒçºŒå¨è„…æŒ‡æ¨™
        return analyzePersistentIndicators()
    }
    
    private func analyzePersistentIndicators() -> [PersistentThreatIndicator] {
        var indicators: [PersistentThreatIndicator] = []
        
        // æª¢æ¸¬é•·æœŸç•°å¸¸æ´»å‹•
        let longTermAnomalies = detectLongTermAnomalies()
        indicators.append(contentsOf: longTermAnomalies)
        
        // æª¢æ¸¬é–“æ­‡æ€§æ´»å‹•
        let intermittentActivities = detectIntermittentActivities()
        indicators.append(contentsOf: intermittentActivities)
        
        // æª¢æ¸¬é€æ­¥å‡ç´šæ¨¡å¼
        let escalationPatterns = detectEscalationPatterns()
        indicators.append(contentsOf: escalationPatterns)
        
        return indicators
    }
    
    private func detectLongTermAnomalies() -> [PersistentThreatIndicator] {
        var indicators: [PersistentThreatIndicator] = []
        
        // åˆ†æç”¨æˆ¶è¡Œç‚ºé•·æœŸè®ŠåŒ–
        let userBehaviorChanges = analyzeLongTermBehaviorChanges()
        
        for change in userBehaviorChanges {
            if change.severity > PersistentThreatThreshold.medium {
                indicators.append(PersistentThreatIndicator(
                    type: .behaviorChange,
                    severity: change.severity,
                    description: change.description,
                    duration: change.duration,
                    affectedEntities: change.affectedUsers
                ))
            }
        }
        
        return indicators
    }
}
```

---

## ğŸš¨ æ¼æ´å…­ï¼šå¤šå‘é‡æ”»æ“Šå”èª¿é˜²ç¦¦ä¸è¶³

### ğŸ” ç™¼ç¾åŸå› 
åœ¨ç¶œåˆæ”»æ“Šå ´æ™¯æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šåŒæ™‚ç™¼å‹•ç¶²è·¯æ”»æ“Šã€åŠ å¯†æ”»æ“Šã€å…§å®¹æ”»æ“Šå’Œä¿¡ä»»æ”»æ“Š
- **ç™¼ç¾å•é¡Œ**ï¼š
  - å„é˜²ç¦¦ç³»çµ±ç¨ç«‹é‹ä½œï¼Œç¼ºä¹å”èª¿
  - ç„¡æ³•è­˜åˆ¥æ”»æ“Šé–“çš„é—œè¯æ€§
  - è³‡æºåˆ†é…ä¸åˆç†

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šé«˜
- **å¯åˆ©ç”¨æ€§**ï¼šé«˜
- **å½±éŸ¿ç¯„åœ**ï¼šæ•´å€‹é˜²ç¦¦é«”ç³»
- **æ”»æ“Šé›£åº¦**ï¼šé«˜

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½å”èª¿é˜²ç¦¦ç³»çµ±
```swift
// å”èª¿é˜²ç¦¦ç³»çµ±
class CoordinatedDefenseSystem {
    private let threatCorrelator = ThreatCorrelator()
    private let defenseOrchestrator = DefenseOrchestrator()
    private let resourceManager = DefenseResourceManager()
    
    func handleMultiVectorAttack(_ threats: [DetectedThreat]) {
        // å¨è„…é—œè¯åˆ†æ
        let correlatedThreats = threatCorrelator.correlateThreats(threats)
        
        // åˆ¶å®šå”èª¿é˜²ç¦¦ç­–ç•¥
        let defenseStrategy = defenseOrchestrator.createStrategy(for: correlatedThreats)
        
        // è³‡æºåˆ†é…å’ŒåŸ·è¡Œ
        resourceManager.allocateResources(for: defenseStrategy)
        
        // åŸ·è¡Œå”èª¿é˜²ç¦¦
        executeCoordinatedDefense(defenseStrategy)
    }
    
    private func executeCoordinatedDefense(_ strategy: DefenseStrategy) {
        // åŒæ­¥åŸ·è¡Œå¤šå€‹é˜²ç¦¦æªæ–½
        let dispatchGroup = DispatchGroup()
        
        for action in strategy.actions {
            dispatchGroup.enter()
            
            switch action.type {
            case .networkDefense:
                executeNetworkDefense(action) {
                    dispatchGroup.leave()
                }
            case .contentFiltering:
                executeContentFiltering(action) {
                    dispatchGroup.leave()
                }
            case .trustSystemProtection:
                executeTrustSystemProtection(action) {
                    dispatchGroup.leave()
                }
            case .accessRestriction:
                executeAccessRestriction(action) {
                    dispatchGroup.leave()
                }
            }
        }
        
        dispatchGroup.notify(queue: .main) {
            self.evaluateDefenseEffectiveness(strategy)
        }
    }
}
```

#### 2. å¯¦æ–½å¨è„…é—œè¯åˆ†æ
```swift
// å¨è„…é—œè¯åˆ†æå™¨
class ThreatCorrelator {
    private let correlationRules: [CorrelationRule] = [
        .timeBasedCorrelation,
        .sourceBasedCorrelation,
        .targetBasedCorrelation,
        .patternBasedCorrelation
    ]
    
    func correlateThreats(_ threats: [DetectedThreat]) -> [CorrelatedThreatGroup] {
        var correlatedGroups: [CorrelatedThreatGroup] = []
        
        for rule in correlationRules {
            let groups = applyCorrelationRule(rule, to: threats)
            correlatedGroups.append(contentsOf: groups)
        }
        
        // åˆä½µé‡ç–Šçš„å¨è„…çµ„
        return mergeOverlappingGroups(correlatedGroups)
    }
    
    private func applyCorrelationRule(_ rule: CorrelationRule, to threats: [DetectedThreat]) -> [CorrelatedThreatGroup] {
        switch rule {
        case .timeBasedCorrelation:
            return correlateByTime(threats)
        case .sourceBasedCorrelation:
            return correlateBySource(threats)
        case .targetBasedCorrelation:
            return correlateByTarget(threats)
        case .patternBasedCorrelation:
            return correlateByPattern(threats)
        }
    }
    
    private func correlateByTime(_ threats: [DetectedThreat]) -> [CorrelatedThreatGroup] {
        let timeWindow: TimeInterval = 300 // 5åˆ†é˜
        var groups: [CorrelatedThreatGroup] = []
        
        let sortedThreats = threats.sorted { $0.timestamp < $1.timestamp }
        
        var currentGroup: [DetectedThreat] = []
        var groupStartTime: Date?
        
        for threat in sortedThreats {
            if let startTime = groupStartTime {
                if threat.timestamp.timeIntervalSince(startTime) <= timeWindow {
                    currentGroup.append(threat)
                } else {
                    // å‰µå»ºæ–°çµ„
                    if currentGroup.count > 1 {
                        groups.append(CorrelatedThreatGroup(
                            threats: currentGroup,
                            correlationType: .temporal,
                            confidence: calculateTemporalConfidence(currentGroup)
                        ))
                    }
                    currentGroup = [threat]
                    groupStartTime = threat.timestamp
                }
            } else {
                currentGroup.append(threat)
                groupStartTime = threat.timestamp
            }
        }
        
        return groups
    }
}
```

#### 3. å¯¦æ–½é˜²ç¦¦è³‡æºç®¡ç†
```swift
// é˜²ç¦¦è³‡æºç®¡ç†å™¨
class DefenseResourceManager {
    private var availableResources: DefenseResources
    private let resourceAllocationStrategy: ResourceAllocationStrategy
    
    init() {
        self.availableResources = DefenseResources()
        self.resourceAllocationStrategy = AdaptiveResourceAllocation()
    }
    
    func allocateResources(for strategy: DefenseStrategy) -> ResourceAllocation {
        let requiredResources = calculateRequiredResources(strategy)
        
        // æª¢æŸ¥è³‡æºå¯ç”¨æ€§
        let availabilityCheck = checkResourceAvailability(requiredResources)
        
        if availabilityCheck.sufficient {
            // åˆ†é…è³‡æº
            let allocation = resourceAllocationStrategy.allocate(
                required: requiredResources,
                available: availableResources
            )
            
            // æ›´æ–°å¯ç”¨è³‡æº
            updateAvailableResources(allocation)
            
            return allocation
        } else {
            // è³‡æºä¸è¶³ï¼Œéœ€è¦å„ªåŒ–åˆ†é…
            return optimizeResourceAllocation(requiredResources)
        }
    }
    
    private func optimizeResourceAllocation(_ required: RequiredResources) -> ResourceAllocation {
        // æ ¹æ“šå¨è„…å„ªå…ˆç´šé‡æ–°åˆ†é…è³‡æº
        let prioritizedRequirements = prioritizeResourceRequirements(required)
        
        var allocation = ResourceAllocation()
        
        for requirement in prioritizedRequirements {
            if canAllocate(requirement) {
                allocation.add(requirement)
                updateAvailableResources(requirement)
            } else {
                // è¨˜éŒ„è³‡æºä¸è¶³è­¦å‘Š
                logResourceShortage(requirement)
            }
        }
        
        return allocation
    }
}
```

---

## ğŸš¨ æ¼æ´ä¸ƒï¼šéš¨æ©Ÿæ•¸ç”Ÿæˆå™¨çµ±è¨ˆç‰¹æ€§ç•¥æœ‰ä¸è¶³

### ğŸ” ç™¼ç¾åŸå› 
åœ¨åŠ å¯†å±¤æ”»æ“Šæ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šå°éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨é€²è¡Œçµ±è¨ˆæ¸¬è©¦
- **ç™¼ç¾å•é¡Œ**ï¼š
  - çµ±è¨ˆéš¨æ©Ÿæ€§æ¸¬è©¦æœªå®Œå…¨é€šé
  - ç†µæ”¶é›†å¯èƒ½ä¸è¶³
  - å¯èƒ½å­˜åœ¨å¯é æ¸¬æ€§

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šä¸­
- **å¯åˆ©ç”¨æ€§**ï¼šä½
- **å½±éŸ¿ç¯„åœ**ï¼šå¯†ç¢¼å­¸å®‰å…¨
- **æ”»æ“Šé›£åº¦**ï¼šé«˜

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¢å¼·éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨
```swift
// å¢å¼·å‹éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨
class EnhancedRandomNumberGenerator {
    private let systemRNG = SystemRandomNumberGenerator()
    private let entropyPool = EntropyPool()
    private let statisticsMonitor = RandomnessStatisticsMonitor()
    
    func generateSecureRandom(length: Int) -> Data {
        // æ”¶é›†é¡å¤–ç†µ
        entropyPool.collectEntropy()
        
        // ç”Ÿæˆéš¨æ©Ÿæ•¸
        var randomData = Data(count: length)
        randomData.withUnsafeMutableBytes { bytes in
            for i in 0..<length {
                bytes[i] = generateSecureByte()
            }
        }
        
        // çµ±è¨ˆæ¸¬è©¦
        let statisticsResult = statisticsMonitor.testRandomness(randomData)
        
        if !statisticsResult.passed {
            // å¦‚æœçµ±è¨ˆæ¸¬è©¦å¤±æ•—ï¼Œé‡æ–°ç”Ÿæˆ
            print("âš ï¸ éš¨æ©Ÿæ•¸çµ±è¨ˆæ¸¬è©¦å¤±æ•—ï¼Œé‡æ–°ç”Ÿæˆ")
            return generateSecureRandom(length: length)
        }
        
        return randomData
    }
    
    private func generateSecureByte() -> UInt8 {
        // çµ„åˆå¤šå€‹ç†µæº
        let systemRandom = systemRNG.next()
        let entropyByte = entropyPool.getEntropy()
        let timingEntropy = getTimingEntropy()
        
        // æ··åˆç†µæº
        let combinedEntropy = systemRandom ^ entropyByte ^ timingEntropy
        
        // æ‡‰ç”¨å¯†ç¢¼å­¸å“ˆå¸Œ
        return cryptographicHash(combinedEntropy)
    }
    
    private func getTimingEntropy() -> UInt8 {
        let nanoTime = DispatchTime.now().uptimeNanoseconds
        return UInt8(nanoTime & 0xFF)
    }
    
    private func cryptographicHash(_ input: UInt8) -> UInt8 {
        // ä½¿ç”¨å¯†ç¢¼å­¸å“ˆå¸Œå‡½æ•¸
        let data = Data([input])
        let hash = SHA256.hash(data: data)
        return hash.first ?? 0
    }
}
```

#### 2. å¯¦æ–½ç†µæ± ç®¡ç†
```swift
// ç†µæ± ç®¡ç†å™¨
class EntropyPool {
    private var entropyQueue: [UInt8] = []
    private let maxPoolSize: Int = 1024
    private let minPoolSize: Int = 256
    private let collectQueue = DispatchQueue(label: "EntropyCollection", qos: .background)
    
    func collectEntropy() {
        collectQueue.async {
            // æ”¶é›†ç³»çµ±ç†µ
            self.collectSystemEntropy()
            
            // æ”¶é›†ç”¨æˆ¶äº¤äº’ç†µ
            self.collectUserInteractionEntropy()
            
            // æ”¶é›†ç¶²è·¯ç†µ
            self.collectNetworkEntropy()
            
            // æ”¶é›†ç¡¬é«”ç†µ
            self.collectHardwareEntropy()
        }
    }
    
    private func collectSystemEntropy() {
        // æ”¶é›†ç³»çµ±ç‹€æ…‹ç†µ
        let processInfo = ProcessInfo.processInfo
        let systemUptime = processInfo.systemUptime
        let memoryUsage = processInfo.physicalMemory
        
        let entropyData = withUnsafeBytes(of: systemUptime) { bytes in
            Array(bytes)
        } + withUnsafeBytes(of: memoryUsage) { bytes in
            Array(bytes)
        }
        
        addToPool(entropyData)
    }
    
    private func collectUserInteractionEntropy() {
        // æ”¶é›†ç”¨æˆ¶äº¤äº’æ™‚é–“ç†µ
        let interactionTime = Date().timeIntervalSince1970
        let timeBytes = withUnsafeBytes(of: interactionTime) { bytes in
            Array(bytes)
        }
        
        addToPool(timeBytes)
    }
    
    private func collectNetworkEntropy() {
        // æ”¶é›†ç¶²è·¯æµé‡ç†µ
        let networkTraffic = getNetworkTrafficEntropy()
        addToPool(networkTraffic)
    }
    
    private func collectHardwareEntropy() {
        // æ”¶é›†ç¡¬é«”ç‹€æ…‹ç†µ
        let hardwareEntropy = getHardwareStateEntropy()
        addToPool(hardwareEntropy)
    }
    
    func getEntropy() -> UInt8 {
        if entropyQueue.count < minPoolSize {
            collectEntropy()
        }
        
        return entropyQueue.removeFirst()
    }
    
    private func addToPool(_ entropy: [UInt8]) {
        entropyQueue.append(contentsOf: entropy)
        
        // é™åˆ¶æ± å¤§å°
        if entropyQueue.count > maxPoolSize {
            entropyQueue.removeFirst(entropyQueue.count - maxPoolSize)
        }
    }
}
```

#### 3. å¯¦æ–½çµ±è¨ˆæ¸¬è©¦ç›£æ§
```swift
// éš¨æ©Ÿæ€§çµ±è¨ˆç›£æ§
class RandomnessStatisticsMonitor {
    private let testSuite = NISTStatisticalTestSuite()
    
    func testRandomness(_ data: Data) -> RandomnessTestResult {
        var passedTests: [String] = []
        var failedTests: [String] = []
        
        // é »ç‡æ¸¬è©¦
        if testSuite.frequencyTest(data) {
            passedTests.append("é »ç‡æ¸¬è©¦")
        } else {
            failedTests.append("é »ç‡æ¸¬è©¦")
        }
        
        // éŠç¨‹æ¸¬è©¦
        if testSuite.runsTest(data) {
            passedTests.append("éŠç¨‹æ¸¬è©¦")
        } else {
            failedTests.append("éŠç¨‹æ¸¬è©¦")
        }
        
        // åºåˆ—æ¸¬è©¦
        if testSuite.serialTest(data) {
            passedTests.append("åºåˆ—æ¸¬è©¦")
        } else {
            failedTests.append("åºåˆ—æ¸¬è©¦")
        }
        
        // è¿‘ä¼¼ç†µæ¸¬è©¦
        if testSuite.approximateEntropyTest(data) {
            passedTests.append("è¿‘ä¼¼ç†µæ¸¬è©¦")
        } else {
            failedTests.append("è¿‘ä¼¼ç†µæ¸¬è©¦")
        }
        
        let passed = failedTests.isEmpty
        
        return RandomnessTestResult(
            passed: passed,
            passedTests: passedTests,
            failedTests: failedTests,
            testDate: Date()
        )
    }
}
```

---

## ğŸš¨ æ¼æ´å…«ï¼šBase64ç·¨ç¢¼æ··æ·†å¯èƒ½ç¹éæª¢æ¸¬

### ğŸ” ç™¼ç¾åŸå› 
åœ¨æƒ¡æ„å…§å®¹æª¢æ¸¬æ¸¬è©¦ä¸­ç™¼ç¾ï¼š
- **æ¸¬è©¦å ´æ™¯**ï¼šä½¿ç”¨Base64ç·¨ç¢¼æ··æ·†æƒ¡æ„å…§å®¹
- **ç™¼ç¾å•é¡Œ**ï¼š
  - å…§å®¹æª¢æ¸¬å™¨ç„¡æ³•è§£æç·¨ç¢¼å…§å®¹
  - ç¼ºä¹å¤šå±¤è§£ç¢¼æ©Ÿåˆ¶
  - æ··æ·†æª¢æ¸¬è¦†è“‹ä¸è¶³

### ğŸ“Š é¢¨éšªè©•ä¼°
- **åš´é‡ç¨‹åº¦**ï¼šä¸­
- **å¯åˆ©ç”¨æ€§**ï¼šä¸­
- **å½±éŸ¿ç¯„åœ**ï¼šå…§å®¹å®‰å…¨
- **æ”»æ“Šé›£åº¦**ï¼šä½

### ğŸ”§ è£œå¼·æ–¹æ¡ˆ

#### 1. å¯¦æ–½å¤šå±¤è§£ç¢¼æª¢æ¸¬
```swift
// å¤šå±¤è§£ç¢¼æª¢æ¸¬å™¨
class MultiLayerDecodingDetector {
    private let supportedEncodings: [EncodingType] = [
        .base64,
        .urlEncoding,
        .htmlEntity,
        .unicode,
        .hexadecimal
    ]
    
    private let maxDecodingDepth: Int = 5
    
    func detectEncodedContent(_ content: Data) -> DecodingResult {
        var currentContent = content
        var decodingLayers: [DecodingLayer] = []
        var depth = 0
        
        while depth < maxDecodingDepth {
            var decoded = false
            
            for encoding in supportedEncodings {
                if let decodedContent = attemptDecoding(currentContent, encoding: encoding) {
                    let layer = DecodingLayer(
                        encoding: encoding,
                        originalSize: currentContent.count,
                        decodedSize: decodedContent.count,
                        depth: depth
                    )
                    
                    decodingLayers.append(layer)
                    currentContent = decodedContent
                    decoded = true
                    break
                }
            }
            
            if !decoded {
                break
            }
            
            depth += 1
        }
        
        return DecodingResult(
            originalContent: content,
            finalContent: currentContent,
            decodingLayers: decodingLayers,
            totalLayers: decodingLayers.count
        )
    }
    
    private func attemptDecoding(_ content: Data, encoding: EncodingType) -> Data? {
        switch encoding {
        case .base64:
            return decodeBase64(content)
        case .urlEncoding:
            return decodeURL(content)
        case .htmlEntity:
            return decodeHTMLEntity(content)
        case .unicode:
            return decodeUnicode(content)
        case .hexadecimal:
            return decodeHexadecimal(content)
        }
    }
    
    private func decodeBase64(_ content: Data) -> Data? {
        guard let string = String(data: content, encoding: .utf8) else {
            return nil
        }
        
        // æ¸…ç†Base64å­—ç¬¦ä¸²
        let cleanedString = string.replacingOccurrences(of: "\\s", with: "", options: .regularExpression)
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆçš„Base64
        if isValidBase64(cleanedString) {
            return Data(base64Encoded: cleanedString)
        }
        
        return nil
    }
    
    private func isValidBase64(_ string: String) -> Bool {
        let base64Pattern = "^[A-Za-z0-9+/]*={0,2}$"
        let regex = try? NSRegularExpression(pattern: base64Pattern)
        let range = NSRange(string.startIndex..., in: string)
        return regex?.firstMatch(in: string, options: [], range: range) != nil
    }
}
```

#### 2. å¯¦æ–½æ··æ·†æ¨¡å¼æª¢æ¸¬
```swift
// æ··æ·†æ¨¡å¼æª¢æ¸¬å™¨
class ObfuscationPatternDetector {
    private let obfuscationPatterns: [ObfuscationPattern] = [
        .base64Pattern,
        .urlEncodingPattern,
        .htmlEntityPattern,
        .unicodeEscapePattern,
        .hexEncodingPattern,
        .doubleEncodingPattern
    ]
    
    func detectObfuscation(_ content: Data) -> ObfuscationDetectionResult {
        var detectedPatterns: [DetectedObfuscationPattern] = []
        
        for pattern in obfuscationPatterns {
            if let detection = detectPattern(pattern, in: content) {
                detectedPatterns.append(detection)
            }
        }
        
        // è¨ˆç®—æ··æ·†å¯èƒ½æ€§
        let obfuscationProbability = calculateObfuscationProbability(detectedPatterns)
        
        return ObfuscationDetectionResult(
            isObfuscated: obfuscationProbability > 0.7,
            probability: obfuscationProbability,
            detectedPatterns: detectedPatterns,
            recommendation: generateObfuscationRecommendation(detectedPatterns)
        )
    }
    
    private func detectPattern(_ pattern: ObfuscationPattern, in content: Data) -> DetectedObfuscationPattern? {
        switch pattern {
        case .base64Pattern:
            return detectBase64Pattern(content)
        case .urlEncodingPattern:
            return detectURLEncodingPattern(content)
        case .htmlEntityPattern:
            return detectHTMLEntityPattern(content)
        case .unicodeEscapePattern:
            return detectUnicodeEscapePattern(content)
        case .hexEncodingPattern:
            return detectHexEncodingPattern(content)
        case .doubleEncodingPattern:
            return detectDoubleEncodingPattern(content)
        }
    }
    
    private func detectBase64Pattern(_ content: Data) -> DetectedObfuscationPattern? {
        guard let string = String(data: content, encoding: .utf8) else {
            return nil
        }
        
        // æª¢æŸ¥Base64ç‰¹å¾µ
        let base64Ratio = calculateBase64Ratio(string)
        let hasBase64Padding = string.hasSuffix("=") || string.hasSuffix("==")
        let lengthMultipleOf4 = string.count % 4 == 0
        
        let confidence = base64Ratio * 0.6 + (hasBase64Padding ? 0.2 : 0.0) + (lengthMultipleOf4 ? 0.2 : 0.0)
        
        if confidence > 0.7 {
            return DetectedObfuscationPattern(
                type: .base64Pattern,
                confidence: confidence,
                location: findPatternLocation(string),
                characteristics: [
                    "Base64å­—ç¬¦æ¯”ä¾‹": "\(Int(base64Ratio * 100))%",
                    "åŒ…å«å¡«å……": hasBase64Padding ? "æ˜¯" : "å¦",
                    "é•·åº¦æ˜¯4çš„å€æ•¸": lengthMultipleOf4 ? "æ˜¯" : "å¦"
                ]
            )
        }
        
        return nil
    }
    
    private func calculateBase64Ratio(_ string: String) -> Double {
        let base64CharacterSet = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")
        let base64Characters = string.unicodeScalars.filter { base64CharacterSet.contains($0) }
        
        return Double(base64Characters.count) / Double(string.count)
    }
}
```

#### 3. å¯¦æ–½å…§å®¹è¦ç¯„åŒ–æª¢æ¸¬
```swift
// å…§å®¹è¦ç¯„åŒ–æª¢æ¸¬å™¨
class ContentNormalizationDetector {
    private let multiLayerDecoder = MultiLayerDecodingDetector()
    private let obfuscationDetector = ObfuscationPatternDetector()
    private let maliciousContentDetector = MaliciousContentDetector()
    
    func normalizeAndDetect(_ content: Data) -> NormalizedDetectionResult {
        // ç¬¬ä¸€æ­¥ï¼šæª¢æ¸¬æ··æ·†
        let obfuscationResult = obfuscationDetector.detectObfuscation(content)
        
        // ç¬¬äºŒæ­¥ï¼šå¤šå±¤è§£ç¢¼
        let decodingResult = multiLayerDecoder.detectEncodedContent(content)
        
        // ç¬¬ä¸‰æ­¥ï¼šè¦ç¯„åŒ–å…§å®¹
        let normalizedContent = normalizeContent(decodingResult.finalContent)
        
        // ç¬¬å››æ­¥ï¼šæª¢æ¸¬æƒ¡æ„å…§å®¹
        let maliciousResult = maliciousContentDetector.detectMaliciousContent(normalizedContent)
        
        // ç¬¬äº”æ­¥ï¼šç¶œåˆè©•ä¼°
        let overallThreatLevel = calculateOverallThreatLevel(
            obfuscation: obfuscationResult,
            decoding: decodingResult,
            malicious: maliciousResult
        )
        
        return NormalizedDetectionResult(
            originalContent: content,
            normalizedContent: normalizedContent,
            obfuscationResult: obfuscationResult,
            decodingResult: decodingResult,
            maliciousResult: maliciousResult,
            overallThreatLevel: overallThreatLevel,
            processingTime: Date()
        )
    }
    
    private func normalizeContent(_ content: Data) -> Data {
        guard let string = String(data: content, encoding: .utf8) else {
            return content
        }
        
        // çµ±ä¸€å­—ç¬¦ç·¨ç¢¼
        let normalizedString = string.precomposedStringWithCanonicalMapping
        
        // ç§»é™¤å¤šé¤˜ç©ºç™½
        let trimmedString = normalizedString.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // è½‰æ›ç‚ºå°å¯«ï¼ˆç”¨æ–¼æª¢æ¸¬ï¼‰
        let lowercasedString = trimmedString.lowercased()
        
        // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
        let cleanedString = lowercasedString.replacingOccurrences(
            of: "[^a-z0-9\\s<>\"'=(){}\\[\\];:,.]",
            with: "",
            options: .regularExpression
        )
        
        return cleanedString.data(using: .utf8) ?? content
    }
    
    private func calculateOverallThreatLevel(
        obfuscation: ObfuscationDetectionResult,
        decoding: DecodingResult,
        malicious: MaliciousContentResult
    ) -> ThreatLevel {
        var riskScore: Double = 0.0
        
        // æ··æ·†é¢¨éšª
        if obfuscation.isObfuscated {
            riskScore += obfuscation.probability * 30.0
        }
        
        // å¤šå±¤ç·¨ç¢¼é¢¨éšª
        if decoding.totalLayers > 1 {
            riskScore += Double(decoding.totalLayers) * 10.0
        }
        
        // æƒ¡æ„å…§å®¹é¢¨éšª
        if malicious.isMalicious {
            riskScore += malicious.confidence * 50.0
        }
        
        // ç¢ºå®šå¨è„…ç­‰ç´š
        switch riskScore {
        case 0..<20:
            return .low
        case 20..<50:
            return .medium
        case 50..<80:
            return .high
        default:
            return .critical
        }
    }
}
```

---

## ğŸ“‹ å¯¦æ–½å„ªå…ˆç´šå»ºè­°

### ğŸš¨ ç«‹å³è™•ç†ï¼ˆ1-2é€±å…§ï¼‰
1. **å…§éƒ¨å¨è„…æª¢æ¸¬æ©Ÿåˆ¶ç¼ºå¤±** - é—œéµé¢¨éšªï¼Œéœ€è¦ç«‹å³å¯¦æ–½
2. **APTæ”»æ“Šæª¢æ¸¬èƒ½åŠ›éœ€è¦å¢å¼·** - é—œéµé¢¨éšªï¼Œå½±éŸ¿æ•´é«”å®‰å…¨

### âš ï¸ é«˜å„ªå…ˆç´šï¼ˆ2-4é€±å…§ï¼‰
3. **é€£æ¥é€Ÿç‡é™åˆ¶ä¸è¶³** - é«˜é¢¨éšªï¼Œå½±éŸ¿ç³»çµ±ç©©å®šæ€§
4. **ä¿¡ä»»è©•åˆ†ç•°å¸¸æª¢æ¸¬æ©Ÿåˆ¶ä¸è¶³** - é«˜é¢¨éšªï¼Œå½±éŸ¿ä¿¡ä»»ç³»çµ±
5. **å¤šå‘é‡æ”»æ“Šå”èª¿é˜²ç¦¦ä¸è¶³** - é«˜é¢¨éšªï¼Œå½±éŸ¿æ•´é«”é˜²è­·

### ğŸ”§ ä¸­å„ªå…ˆç´šï¼ˆ1-2å€‹æœˆå…§ï¼‰
6. **é›¶æ—¥æ”»æ“Šæª¢æ¸¬èƒ½åŠ›éœ€è¦å¢å¼·** - é«˜é¢¨éšªï¼Œä½†æ”»æ“Šé›£åº¦é«˜
7. **Base64ç·¨ç¢¼æ··æ·†å¯èƒ½ç¹éæª¢æ¸¬** - ä¸­é¢¨éšªï¼Œå®¹æ˜“ä¿®å¾©
8. **éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨çµ±è¨ˆç‰¹æ€§ç•¥æœ‰ä¸è¶³** - ä¸­é¢¨éšªï¼Œå½±éŸ¿å¯†ç¢¼å­¸

---

## ğŸ”„ æŒçºŒæ”¹é€²å»ºè­°

### 1. å»ºç«‹å®šæœŸè©•ä¼°æ©Ÿåˆ¶
- æ¯é€±åŸ·è¡Œè‡ªå‹•åŒ–æ»²é€æ¸¬è©¦
- æ¯æœˆé€²è¡Œæ‰‹å‹•å®‰å…¨å¯©è¨ˆ
- æ¯å­£åº¦æ›´æ–°å¨è„…æ¨¡å‹

### 2. å¯¦æ–½æŒçºŒç›£æ§
- éƒ¨ç½²å¯¦æ™‚å®‰å…¨ç›£æ§ç³»çµ±
- å»ºç«‹å®‰å…¨æŒ‡æ¨™å„€è¡¨æ¿
- è¨­ç½®è‡ªå‹•å‘Šè­¦æ©Ÿåˆ¶

### 3. åœ˜éšŠåŸ¹è¨“å’Œæ„è­˜æå‡
- å®šæœŸé€²è¡Œå®‰å…¨åŸ¹è¨“
- å»ºç«‹å®‰å…¨æœ€ä½³å¯¦å‹™æŒ‡å—
- å¯¦æ–½å®‰å…¨ç·¨ç¢¼æ¨™æº–

### 4. å»ºç«‹äº‹ä»¶å›æ‡‰è¨ˆç•«
- åˆ¶å®šå®‰å…¨äº‹ä»¶å›æ‡‰æµç¨‹
- å»ºç«‹ç·Šæ€¥è¯çµ¡æ©Ÿåˆ¶
- å®šæœŸæ¼”ç·´äº‹ä»¶å›æ‡‰ç¨‹åº

é€™ä»½è©³ç´°çš„æ¼æ´åˆ†æå ±å‘Šæä¾›äº†å®Œæ•´çš„è£œå¼·æ–¹æ¡ˆï¼Œå»ºè­°å„ªå…ˆè™•ç†é—œéµå’Œé«˜é¢¨éšªæ¼æ´ï¼Œç„¶å¾Œé€æ­¥å¯¦æ–½å…¶ä»–æ”¹é€²æªæ–½ã€‚